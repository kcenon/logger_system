<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Logger System: Writer Composition and Decorator Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Logger System<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-performance C++20 thread-safe logging system with asynchronous capabilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__2home_2runner_2work_2logger__system_2logger__system_2docs_2WRITER__GUIDE.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Writer Composition and Decorator Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md2723"></a> <b>logger_system Writer Framework</b> (<code>include/kcenon/logger/writers/</code>)</p>
<p>The writer framework in logger_system uses the <b>Decorator Pattern</b> to enable flexible, composable log processing pipelines. With 18 writer types (5 base writers + 13 processing decorators), you can build high-performance logging configurations achieving <b>4.34M msg/sec throughput</b> and <b>148ns latency</b>.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md2725"></a>
Table of Contents</h1>
<ol type="1">
<li>Architecture Overview</li>
<li>Writer Catalog<ul>
<li>Base Writers</li>
<li>Decorator Writers</li>
</ul>
</li>
<li>Composition Patterns</li>
<li>Recommended Stacks</li>
<li>Code Examples</li>
<li>Performance Impact</li>
<li>Best Practices</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md2727"></a>
Architecture Overview</h1>
<h2><a class="anchor" id="autotoc_md2728"></a>
Decorator Pattern</h2>
<p>Writers in logger_system follow the <b>Decorator Pattern</b> (Gang of Four), allowing dynamic addition of responsibilities to objects:</p>
<div class="fragment"><div class="line">┌──────────────────────────────────────────────────┐</div>
<div class="line">│          log_writer_interface                     │</div>
<div class="line">│  + write(const log_entry&amp;): VoidResult            │</div>
<div class="line">│  + flush(): VoidResult                            │</div>
<div class="line">│  + get_name(): string                             │</div>
<div class="line">│  + is_healthy(): bool                             │</div>
<div class="line">└────────────────┬─────────────────────────────────┘</div>
<div class="line">                 │</div>
<div class="line">        ┌────────┼────────┐</div>
<div class="line">        ▼                 ▼</div>
<div class="line">┌──────────────┐  ┌──────────────────┐</div>
<div class="line">│ base_writer  │  │decorator_writer_ │</div>
<div class="line">│              │  │     base         │</div>
<div class="line">│ (Concrete    │  │                  │</div>
<div class="line">│  writers)    │  │ (Wraps another   │</div>
<div class="line">│              │  │  writer)         │</div>
<div class="line">└──────────────┘  └──────────────────┘</div>
</div><!-- fragment --><p><b>Key Concepts:</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Concept   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Examples    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Base Writer</b>   </td><td class="markdownTableBodyNone">Concrete output destination   </td><td class="markdownTableBodyNone"><code>console_writer</code>, <code>file_writer</code>, <code>network_writer</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Decorator Writer</b>   </td><td class="markdownTableBodyNone">Processing layer that wraps another writer   </td><td class="markdownTableBodyNone"><code>async_writer</code>, <code>filtered_writer</code>, <code>batch_writer</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Stacking</b>   </td><td class="markdownTableBodyNone">Decorators wrap decorators wrap base writers   </td><td class="markdownTableBodyNone"><code>async(filtered(formatted(console)))</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Interface</b>   </td><td class="markdownTableBodyNone">All writers implement <code>log_writer_interface</code>   </td><td class="markdownTableBodyNone">Enables unlimited composition   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2729"></a>
Inheritance Chain</h2>
<p><b>Base Writers:</b> </p><div class="fragment"><div class="line"><span class="keyword">class </span>console_writer : <span class="keyword">public</span> log_writer_interface, <span class="keyword">public</span> sync_writer_tag {</div>
<div class="line">    <span class="comment">// Direct implementation - no wrapped writer</span></div>
<div class="line">    common::VoidResult write(<span class="keyword">const</span> log_entry&amp; entry)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Write directly to stdout/stderr</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>Decorator Writers:</b> </p><div class="fragment"><div class="line"><span class="keyword">class </span>async_writer : <span class="keyword">public</span> decorator_writer_base {</div>
<div class="line">    <span class="comment">// Wraps another writer</span></div>
<div class="line">    std::unique_ptr&lt;log_writer_interface&gt; wrapped_;</div>
<div class="line"> </div>
<div class="line">    common::VoidResult write(<span class="keyword">const</span> log_entry&amp; entry)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Add async behavior, then delegate:</span></div>
<div class="line">        <span class="keywordflow">return</span> wrapped_-&gt;write(entry);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>Decorator Base:</b> </p><div class="fragment"><div class="line"><span class="keyword">class </span>decorator_writer_base : <span class="keyword">public</span> log_writer_interface {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    log_writer_interface&amp; wrapped() noexcept;  <span class="comment">// Access wrapped writer</span></div>
<div class="line">private:</div>
<div class="line">    std::unique_ptr&lt;log_writer_interface&gt; wrapped_;</div>
<div class="line">    std::<span class="keywordtype">string</span> decorator_name_;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2730"></a>
Stack Visualization</h2>
<p>Example stack: <b>Production File Logging</b></p>
<div class="fragment"><div class="line">[Application Code]</div>
<div class="line">    ↓ log_entry</div>
<div class="line">[filtered_writer] ← Drop DEBUG/TRACE in production</div>
<div class="line">    ↓</div>
<div class="line">[formatted_writer] ← Add timestamp, level, source location</div>
<div class="line">    ↓</div>
<div class="line">[async_writer] ← Non-blocking (queue-based)</div>
<div class="line">    ↓</div>
<div class="line">[batch_writer] ← Accumulate 100 messages</div>
<div class="line">    ↓</div>
<div class="line">[buffered_writer] ← Memory buffer (32KB)</div>
<div class="line">    ↓</div>
<div class="line">[rotating_file_writer] ← Write to disk with rotation</div>
</div><!-- fragment --><p><b>Call flow (write operation):</b></p><ol type="1">
<li>App calls <code>filtered_writer::write(entry)</code></li>
<li>Filtered writer checks level → pass</li>
<li>Calls <code>formatted_writer::write(entry)</code></li>
<li>Formatted writer formats message → delegates</li>
<li>Calls <code>async_writer::write(entry)</code></li>
<li>Async writer enqueues → returns immediately</li>
<li>Background thread: calls <code>batch_writer::write(entry)</code></li>
<li>Batch writer accumulates → flushes batch of 100</li>
<li>Calls <code>buffered_writer::write(entry)</code> × 100</li>
<li>Buffered writer fills buffer → flushes to file</li>
<li>Calls <code>rotating_file_writer::write(entry)</code> × 100</li>
<li>Rotating file writer writes to disk, rotates if needed</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md2732"></a>
Writer Catalog</h1>
<h2><a class="anchor" id="autotoc_md2733"></a>
Base Writers</h2>
<p>Base writers are concrete implementations that write to actual destinations. They implement <code>log_writer_interface</code> directly.</p>
<h3><a class="anchor" id="autotoc_md2734"></a>
1. &lt;tt&gt;console_writer&lt;/tt&gt;</h3>
<p><b>Output:</b> <code>stdout</code> (info/debug/trace) or <code>stderr</code> (warn/error/fatal)</p>
<p><b>Description:</b> Thread-safe console output with optional ANSI coloring.</p>
<p><b>Features:</b></p><ul>
<li>Auto-detect terminal color support</li>
<li>Different colors for each log level</li>
<li>Mutex-protected for thread safety</li>
</ul>
<p><b>Use Cases:</b></p><ul>
<li>Development (immediate visual feedback)</li>
<li>Interactive debugging</li>
<li>Docker containers (stdout/stderr collection)</li>
</ul>
<p><b>Constructor:</b> </p><div class="fragment"><div class="line">console_writer(<span class="keywordtype">bool</span> use_stderr = <span class="keyword">false</span>,</div>
<div class="line">               <span class="keywordtype">bool</span> auto_detect_color = <span class="keyword">true</span>,</div>
<div class="line">               std::unique_ptr&lt;log_formatter_interface&gt; formatter = <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;console_writer&gt;(</div>
<div class="line">    <span class="keyword">false</span>,  <span class="comment">// use stdout</span></div>
<div class="line">    <span class="keyword">true</span>    <span class="comment">// auto-detect color</span></div>
<div class="line">);</div>
</div><!-- fragment --><hr  />
<h3><a class="anchor" id="autotoc_md2736"></a>
2. &lt;tt&gt;file_writer&lt;/tt&gt;</h3>
<p><b>Output:</b> Single file</p>
<p><b>Description:</b> Writes to a single log file with optional append mode.</p>
<p><b>Features:</b></p><ul>
<li>Create parent directories automatically</li>
<li>Append or overwrite mode</li>
<li>File permission control (0644)</li>
<li>Thread-safe writes (mutex-protected)</li>
</ul>
<p><b>Use Cases:</b></p><ul>
<li>Simple logging to single file</li>
<li>Base layer for other decorators</li>
<li>Development/testing</li>
</ul>
<p><b>Constructor:</b> </p><div class="fragment"><div class="line">file_writer(<span class="keyword">const</span> std::filesystem::path&amp; file_path,</div>
<div class="line">            <span class="keywordtype">bool</span> append = <span class="keyword">true</span>,</div>
<div class="line">            std::unique_ptr&lt;log_formatter_interface&gt; formatter = <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;file_writer&gt;(</div>
<div class="line">    <span class="stringliteral">&quot;/var/log/myapp/app.log&quot;</span>,</div>
<div class="line">    <span class="keyword">true</span>  <span class="comment">// append mode</span></div>
<div class="line">);</div>
</div><!-- fragment --><hr  />
<h3><a class="anchor" id="autotoc_md2738"></a>
3. &lt;tt&gt;rotating_file_writer&lt;/tt&gt;</h3>
<p><b>Output:</b> Multiple files with rotation</p>
<p><b>Description:</b> Writes to files that rotate based on size or time.</p>
<p><b>Features:</b></p><ul>
<li>Size-based rotation (e.g., 100MB per file)</li>
<li>Time-based rotation (daily, hourly)</li>
<li>Configurable max file count (auto-delete old files)</li>
<li>Filename pattern (e.g., <code>app.log.1</code>, <code>app.log.2</code>)</li>
</ul>
<p><b>Use Cases:</b></p><ul>
<li>Production logging</li>
<li>Long-running services</li>
<li>Compliance (retention policies)</li>
</ul>
<p><b>Constructor:</b> </p><div class="fragment"><div class="line">rotating_file_writer(<span class="keyword">const</span> std::filesystem::path&amp; base_path,</div>
<div class="line">                    <span class="keywordtype">size_t</span> max_file_size = 100 * 1024 * 1024,  <span class="comment">// 100MB</span></div>
<div class="line">                    <span class="keywordtype">size_t</span> max_files = 10,</div>
<div class="line">                    std::unique_ptr&lt;log_formatter_interface&gt; formatter = <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;rotating_file_writer&gt;(</div>
<div class="line">    <span class="stringliteral">&quot;/var/log/myapp/app.log&quot;</span>,</div>
<div class="line">    50 * 1024 * 1024,  <span class="comment">// 50MB per file</span></div>
<div class="line">    5                   <span class="comment">// keep 5 files</span></div>
<div class="line">);</div>
</div><!-- fragment --><hr  />
<h3><a class="anchor" id="autotoc_md2740"></a>
4. &lt;tt&gt;network_writer&lt;/tt&gt;</h3>
<p><b>Output:</b> Remote log server (TCP/UDP)</p>
<p><b>Description:</b> Sends logs to a remote server over network.</p>
<p><b>Features:</b></p><ul>
<li>TCP or UDP transport</li>
<li>Connection pooling</li>
<li>Automatic reconnection</li>
<li>Configurable timeout</li>
</ul>
<p><b>Use Cases:</b></p><ul>
<li>Centralized logging (ELK, Splunk, Graylog)</li>
<li>Distributed systems</li>
<li>Microservices (log aggregation)</li>
</ul>
<p><b>Constructor:</b> </p><div class="fragment"><div class="line">network_writer(<span class="keyword">const</span> std::string&amp; host,</div>
<div class="line">               uint16_t port,</div>
<div class="line">               protocol proto = protocol::tcp,</div>
<div class="line">               std::unique_ptr&lt;log_formatter_interface&gt; formatter = <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;network_writer&gt;(</div>
<div class="line">    <span class="stringliteral">&quot;logs.example.com&quot;</span>,</div>
<div class="line">    5140,  <span class="comment">// TCP port</span></div>
<div class="line">    network_writer::protocol::tcp</div>
<div class="line">);</div>
</div><!-- fragment --><hr  />
<h3><a class="anchor" id="autotoc_md2742"></a>
5. &lt;tt&gt;otlp_writer&lt;/tt&gt;</h3>
<p><b>Output:</b> OpenTelemetry Protocol (OTLP) endpoint</p>
<p><b>Description:</b> Exports logs to OTLP-compatible backends (OpenTelemetry Collector, Jaeger, etc.).</p>
<p><b>Features:</b></p><ul>
<li>OTLP gRPC or HTTP/protobuf</li>
<li>Structured log export</li>
<li>Integration with traces/metrics</li>
<li>Batch export for efficiency</li>
</ul>
<p><b>Use Cases:</b></p><ul>
<li>OpenTelemetry observability</li>
<li>Cloud-native monitoring</li>
<li>Distributed tracing correlation</li>
</ul>
<p><b>Constructor:</b> </p><div class="fragment"><div class="line">otlp_writer(<span class="keyword">const</span> std::string&amp; endpoint,</div>
<div class="line">            otlp_protocol proto = otlp_protocol::grpc,</div>
<div class="line">            std::unique_ptr&lt;log_formatter_interface&gt; formatter = <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;otlp_writer&gt;(</div>
<div class="line">    <span class="stringliteral">&quot;http://otel-collector:4317&quot;</span>,</div>
<div class="line">    otlp_writer::otlp_protocol::grpc</div>
<div class="line">);</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md2744"></a>
Decorator Writers</h2>
<p>Decorator writers wrap other writers to add processing capabilities. They inherit from <code>decorator_writer_base</code>.</p>
<h3><a class="anchor" id="autotoc_md2745"></a>
6. &lt;tt&gt;async_writer&lt;/tt&gt;</h3>
<p><b>Function:</b> Asynchronous (non-blocking) writes</p>
<p><b>Description:</b> Wraps any writer and makes it asynchronous using a background thread and queue.</p>
<p><b>Features:</b></p><ul>
<li>Non-blocking <code>write()</code> (enqueues and returns)</li>
<li>Background worker thread</li>
<li>Configurable queue size (default: 10,000)</li>
<li>Graceful shutdown (flush on destruction)</li>
</ul>
<p><b>Use Cases:</b></p><ul>
<li>High-throughput logging (don't block app)</li>
<li>I/O-heavy writers (file, network)</li>
<li>Real-time applications</li>
</ul>
<p><b>Constructor:</b> </p><div class="fragment"><div class="line">async_writer(std::unique_ptr&lt;log_writer_interface&gt; wrapped,</div>
<div class="line">             <span class="keywordtype">size_t</span> queue_size = 10000,</div>
<div class="line">             std::chrono::seconds flush_timeout = std::chrono::seconds(5));</div>
</div><!-- fragment --><p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;async_writer&gt;(</div>
<div class="line">    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;/var/log/app.log&quot;</span>),</div>
<div class="line">    50000  <span class="comment">// queue size</span></div>
<div class="line">);</div>
<div class="line">writer-&gt;start();  <span class="comment">// Start background thread</span></div>
</div><!-- fragment --><p><b>Performance Impact:</b></p><ul>
<li><b>Latency:</b> +10-50ns (enqueue time)</li>
<li><b>Throughput:</b> +1000% (non-blocking)</li>
<li><b>Memory:</b> Queue size × log entry size (~100-500 bytes each)</li>
</ul>
<hr  />
<h3><a class="anchor" id="autotoc_md2747"></a>
7. &lt;tt&gt;batch_writer&lt;/tt&gt;</h3>
<p><b>Function:</b> Batching (accumulate N messages before flush)</p>
<p><b>Description:</b> Accumulates log entries and writes them in batches to reduce syscall overhead.</p>
<p><b>Features:</b></p><ul>
<li>Configurable batch size (default: 100)</li>
<li>Auto-flush on timeout (default: 1s)</li>
<li>Flush on critical logs (optional)</li>
</ul>
<p><b>Use Cases:</b></p><ul>
<li>Reduce I/O syscalls (file, network)</li>
<li>Improve throughput</li>
<li>Combine with <code>async_writer</code></li>
</ul>
<p><b>Constructor:</b> </p><div class="fragment"><div class="line">batch_writer(std::unique_ptr&lt;log_writer_interface&gt; wrapped,</div>
<div class="line">             <span class="keywordtype">size_t</span> batch_size = 100,</div>
<div class="line">             std::chrono::milliseconds flush_interval = std::chrono::milliseconds(1000));</div>
</div><!-- fragment --><p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;batch_writer&gt;(</div>
<div class="line">    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;/var/log/app.log&quot;</span>),</div>
<div class="line">    200,  <span class="comment">// batch size</span></div>
<div class="line">    std::chrono::milliseconds(500)  <span class="comment">// flush every 500ms</span></div>
<div class="line">);</div>
</div><!-- fragment --><p><b>Performance Impact:</b></p><ul>
<li><b>Latency:</b> +0-1000ms (batching delay)</li>
<li><b>Throughput:</b> +500% (fewer syscalls)</li>
<li><b>Memory:</b> Batch size × log entry size</li>
</ul>
<hr  />
<h3><a class="anchor" id="autotoc_md2749"></a>
8. &lt;tt&gt;buffered_writer&lt;/tt&gt;</h3>
<p><b>Function:</b> Buffering (memory buffer before write)</p>
<p><b>Description:</b> Buffers log messages in memory before flushing to the wrapped writer.</p>
<p><b>Features:</b></p><ul>
<li>Configurable buffer size (default: 64KB)</li>
<li>Auto-flush when buffer full</li>
<li>Manual flush support</li>
</ul>
<p><b>Use Cases:</b></p><ul>
<li>Reduce disk writes</li>
<li>Improve file I/O performance</li>
<li>Combine with <code>rotating_file_writer</code></li>
</ul>
<p><b>Constructor:</b> </p><div class="fragment"><div class="line">buffered_writer(std::unique_ptr&lt;log_writer_interface&gt; wrapped,</div>
<div class="line">                <span class="keywordtype">size_t</span> buffer_size = 65536);  <span class="comment">// 64KB</span></div>
</div><!-- fragment --><p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;buffered_writer&gt;(</div>
<div class="line">    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;/var/log/app.log&quot;</span>),</div>
<div class="line">    128 * 1024  <span class="comment">// 128KB buffer</span></div>
<div class="line">);</div>
</div><!-- fragment --><p><b>Performance Impact:</b></p><ul>
<li><b>Latency:</b> +0-10ms (buffer flush)</li>
<li><b>Throughput:</b> +300% (fewer disk writes)</li>
<li><b>Memory:</b> Buffer size (e.g., 64KB)</li>
</ul>
<hr  />
<h3><a class="anchor" id="autotoc_md2751"></a>
9. &lt;tt&gt;filtered_writer&lt;/tt&gt;</h3>
<p><b>Function:</b> Filtering (level/category-based)</p>
<p><b>Description:</b> Filters log entries based on level or custom predicate before writing.</p>
<p><b>Features:</b></p><ul>
<li>Level-based filtering (e.g., only WARN+)</li>
<li>Category filtering (e.g., only "auth" category)</li>
<li>Custom predicate support</li>
<li>Zero overhead for filtered messages</li>
</ul>
<p><b>Use Cases:</b></p><ul>
<li>Production (only log errors)</li>
<li>Separate logs by severity</li>
<li>Reduce log volume</li>
</ul>
<p><b>Constructor:</b> </p><div class="fragment"><div class="line">filtered_writer(std::unique_ptr&lt;log_writer_interface&gt; wrapped,</div>
<div class="line">                log_level min_level = log_level::debug);</div>
</div><!-- fragment --><p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;filtered_writer&gt;(</div>
<div class="line">    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;/var/log/errors.log&quot;</span>),</div>
<div class="line">    log_level::error  <span class="comment">// only ERROR and FATAL</span></div>
<div class="line">);</div>
</div><!-- fragment --><p><b>Performance Impact:</b></p><ul>
<li><b>Latency:</b> +5-10ns (level check)</li>
<li><b>Throughput:</b> No impact (drops messages early)</li>
<li><b>Memory:</b> Negligible</li>
</ul>
<hr  />
<h3><a class="anchor" id="autotoc_md2753"></a>
10. &lt;tt&gt;formatted_writer&lt;/tt&gt;</h3>
<p><b>Function:</b> Formatting (message templating)</p>
<p><b>Description:</b> Applies a formatter to log entries before writing.</p>
<p><b>Features:</b></p><ul>
<li>Pluggable formatters (JSON, timestamp, custom)</li>
<li>Supports all formatter types</li>
<li>Can be composed at any stack level</li>
</ul>
<p><b>Use Cases:</b></p><ul>
<li>JSON output for log aggregators</li>
<li>Custom format per destination</li>
<li>Add timestamps/metadata</li>
</ul>
<p><b>Constructor:</b> </p><div class="fragment"><div class="line">formatted_writer(std::unique_ptr&lt;log_writer_interface&gt; wrapped,</div>
<div class="line">                 std::unique_ptr&lt;log_formatter_interface&gt; formatter);</div>
</div><!-- fragment --><p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;formatted_writer&gt;(</div>
<div class="line">    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;/var/log/app.json&quot;</span>),</div>
<div class="line">    std::make_unique&lt;json_formatter&gt;()</div>
<div class="line">);</div>
</div><!-- fragment --><p><b>Performance Impact:</b></p><ul>
<li><b>Latency:</b> +20-100ns (formatting)</li>
<li><b>Throughput:</b> -10-20% (CPU overhead)</li>
<li><b>Memory:</b> Formatted string allocation</li>
</ul>
<hr  />
<h3><a class="anchor" id="autotoc_md2755"></a>
11. &lt;tt&gt;thread_safe_writer&lt;/tt&gt;</h3>
<p><b>Function:</b> Thread safety (mutex-protected)</p>
<p><b>Description:</b> Wraps any writer with mutex protection for thread safety.</p>
<p><b>Features:</b></p><ul>
<li>Mutex-protected <code>write()</code> and <code>flush()</code></li>
<li>Ensures serialized access</li>
<li>Useful for non-thread-safe writers</li>
</ul>
<p><b>Use Cases:</b></p><ul>
<li>Wrap custom writers</li>
<li>Ensure thread safety in async logging</li>
<li>Protect shared resources</li>
</ul>
<p><b>Constructor:</b> </p><div class="fragment"><div class="line">thread_safe_writer(std::unique_ptr&lt;log_writer_interface&gt; wrapped);</div>
</div><!-- fragment --><p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;thread_safe_writer&gt;(</div>
<div class="line">    std::make_unique&lt;my_custom_writer&gt;()</div>
<div class="line">);</div>
</div><!-- fragment --><p><b>Performance Impact:</b></p><ul>
<li><b>Latency:</b> +50-200ns (mutex lock/unlock)</li>
<li><b>Throughput:</b> -30-50% (contention)</li>
<li><b>Memory:</b> Mutex overhead (~64 bytes)</li>
</ul>
<hr  />
<h3><a class="anchor" id="autotoc_md2757"></a>
12. &lt;tt&gt;encrypted_writer&lt;/tt&gt;</h3>
<p><b>Function:</b> Encryption (encrypt log content)</p>
<p><b>Description:</b> Encrypts log messages before writing (AES-256-GCM).</p>
<p><b>Features:</b></p><ul>
<li>AES-256-GCM encryption</li>
<li>Secure key management</li>
<li>HMAC authentication</li>
<li>Key rotation support</li>
</ul>
<p><b>Use Cases:</b></p><ul>
<li>Compliance (HIPAA, GDPR)</li>
<li>Sensitive data logging</li>
<li>Tamper-evident logs</li>
</ul>
<p><b>Constructor:</b> </p><div class="fragment"><div class="line">encrypted_writer(std::unique_ptr&lt;log_writer_interface&gt; wrapped,</div>
<div class="line">                 <span class="keyword">const</span> secure_key&amp; encryption_key);</div>
</div><!-- fragment --><p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> key = secure_key_storage::generate_key(32);  <span class="comment">// AES-256</span></div>
<div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;encrypted_writer&gt;(</div>
<div class="line">    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;/var/log/secure.log&quot;</span>),</div>
<div class="line">    key</div>
<div class="line">);</div>
</div><!-- fragment --><p><b>Performance Impact:</b></p><ul>
<li><b>Latency:</b> +100-500ns (encryption)</li>
<li><b>Throughput:</b> -30-40% (crypto overhead)</li>
<li><b>Memory:</b> Key storage (~32 bytes)</li>
</ul>
<hr  />
<h3><a class="anchor" id="autotoc_md2759"></a>
13. &lt;tt&gt;critical_writer&lt;/tt&gt;</h3>
<p><b>Function:</b> Priority (immediate flush for critical logs)</p>
<p><b>Description:</b> Immediately flushes wrapped writer when critical/fatal logs are received.</p>
<p><b>Features:</b></p><ul>
<li>Immediate flush on critical levels</li>
<li>Configurable threshold (default: FATAL)</li>
<li>Ensures critical logs are persisted</li>
</ul>
<p><b>Use Cases:</b></p><ul>
<li>Crash dumps</li>
<li>Security alerts</li>
<li>Compliance audit logs</li>
</ul>
<p><b>Constructor:</b> </p><div class="fragment"><div class="line">critical_writer(std::unique_ptr&lt;log_writer_interface&gt; wrapped,</div>
<div class="line">                log_level critical_threshold = log_level::fatal);</div>
</div><!-- fragment --><p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;critical_writer&gt;(</div>
<div class="line">    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;/var/log/app.log&quot;</span>),</div>
<div class="line">    log_level::error  <span class="comment">// flush on ERROR+</span></div>
<div class="line">);</div>
</div><!-- fragment --><p><b>Performance Impact:</b></p><ul>
<li><b>Latency:</b> +0-10ms (flush on critical)</li>
<li><b>Throughput:</b> No impact (rare events)</li>
<li><b>Memory:</b> Negligible</li>
</ul>
<hr  />
<h3><a class="anchor" id="autotoc_md2761"></a>
14. &lt;tt&gt;composite_writer&lt;/tt&gt;</h3>
<p><b>Function:</b> Fan-out (write to multiple destinations)</p>
<p><b>Description:</b> Writes to multiple wrapped writers simultaneously.</p>
<p><b>Features:</b></p><ul>
<li>Write to N writers in parallel</li>
<li>Independent error handling per writer</li>
<li>Configurable success criteria (all, any, majority)</li>
</ul>
<p><b>Use Cases:</b></p><ul>
<li>Multi-destination logging (file + network)</li>
<li>Redundancy (primary + backup)</li>
<li>Fan-out to different formats</li>
</ul>
<p><b>Constructor:</b> </p><div class="fragment"><div class="line">composite_writer();</div>
<div class="line"><span class="keywordtype">void</span> add_writer(std::unique_ptr&lt;log_writer_interface&gt; writer);</div>
</div><!-- fragment --><p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> composite = std::make_unique&lt;composite_writer&gt;();</div>
<div class="line">composite-&gt;add_writer(std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;/var/log/app.log&quot;</span>));</div>
<div class="line">composite-&gt;add_writer(std::make_unique&lt;network_writer&gt;(<span class="stringliteral">&quot;logs.example.com&quot;</span>, 5140));</div>
</div><!-- fragment --><p><b>Performance Impact:</b></p><ul>
<li><b>Latency:</b> max(writer1, writer2, ...) (parallel)</li>
<li><b>Throughput:</b> min(writer1, writer2, ...) (bottleneck)</li>
<li><b>Memory:</b> N × wrapped writer memory</li>
</ul>
<hr  />
<h3><a class="anchor" id="autotoc_md2763"></a>
15. &lt;tt&gt;queued_writer_base&lt;/tt&gt;</h3>
<p><b>Function:</b> Queuing (base for queue-based writers)</p>
<p><b>Description:</b> Abstract base class for queue-based writers (shared by <code>async_writer</code>, <code>batch_writer</code>).</p>
<p><b>Features:</b></p><ul>
<li>Thread-safe queue management</li>
<li>Overflow policies (drop, block, expand)</li>
<li>Shared queue logic</li>
</ul>
<p><b>Use Cases:</b></p><ul>
<li>Base class for custom queue-based writers</li>
<li>Not used directly by applications</li>
</ul>
<p><b>Note:</b> Not typically instantiated directly; used as a base class.</p>
<hr  />
<h3><a class="anchor" id="autotoc_md2765"></a>
16. &lt;tt&gt;legacy_writer_adapter&lt;/tt&gt;</h3>
<p><b>Function:</b> Compatibility (adapter for legacy writer interface)</p>
<p><b>Description:</b> Adapts legacy writer API to modern <code>log_writer_interface</code>.</p>
<p><b>Features:</b></p><ul>
<li>Backward compatibility</li>
<li>Bridge legacy code to new system</li>
<li>No performance overhead</li>
</ul>
<p><b>Use Cases:</b></p><ul>
<li>Migrating from old logger versions</li>
<li>Compatibility with legacy integrations</li>
<li>Gradual migration path</li>
</ul>
<p><b>Constructor:</b> </p><div class="fragment"><div class="line">legacy_writer_adapter(std::unique_ptr&lt;legacy_writer&gt; legacy);</div>
</div><!-- fragment --><p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> adapter = std::make_unique&lt;legacy_writer_adapter&gt;(</div>
<div class="line">    std::make_unique&lt;my_old_writer&gt;()</div>
<div class="line">);</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md2767"></a>
Composition Patterns</h1>
<h2><a class="anchor" id="autotoc_md2768"></a>
Pattern 1: Simple Console (Development)</h2>
<p><b>Stack:</b> </p><div class="fragment"><div class="line">console_writer</div>
</div><!-- fragment --><p><b>Use Case:</b> Local development, quick debugging</p>
<p><b>Code:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> logger = logger_builder::create()</div>
<div class="line">    .with_console_writer()</div>
<div class="line">    .build();</div>
</div><!-- fragment --><p><b>Characteristics:</b></p><ul>
<li><b>Throughput:</b> 500K msg/sec</li>
<li><b>Latency:</b> 2µs (blocking I/O)</li>
<li><b>Memory:</b> Minimal (~1KB)</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md2770"></a>
Pattern 2: Async Console (Development + Performance)</h2>
<p><b>Stack:</b> </p><div class="fragment"><div class="line">async_writer</div>
<div class="line">  └─ console_writer</div>
</div><!-- fragment --><p><b>Use Case:</b> Development with high log volume</p>
<p><b>Code:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> logger = logger_builder::create()</div>
<div class="line">    .with_writer(std::make_unique&lt;async_writer&gt;(</div>
<div class="line">        std::make_unique&lt;console_writer&gt;()</div>
<div class="line">    ))</div>
<div class="line">    .build();</div>
</div><!-- fragment --><p><b>Characteristics:</b></p><ul>
<li><b>Throughput:</b> 4.3M msg/sec</li>
<li><b>Latency:</b> 148ns (non-blocking)</li>
<li><b>Memory:</b> Queue (10K entries × ~200B = 2MB)</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md2772"></a>
Pattern 3: Filtered Formatted File (Production)</h2>
<p><b>Stack:</b> </p><div class="fragment"><div class="line">filtered_writer (WARN+)</div>
<div class="line">  └─ formatted_writer (timestamp + level)</div>
<div class="line">      └─ rotating_file_writer</div>
</div><!-- fragment --><p><b>Use Case:</b> Production error logging</p>
<p><b>Code:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> logger = logger_builder::create()</div>
<div class="line">    .with_writer(std::make_unique&lt;filtered_writer&gt;(</div>
<div class="line">        std::make_unique&lt;formatted_writer&gt;(</div>
<div class="line">            std::make_unique&lt;rotating_file_writer&gt;(</div>
<div class="line">                <span class="stringliteral">&quot;/var/log/app/errors.log&quot;</span>,</div>
<div class="line">                50 * 1024 * 1024,  <span class="comment">// 50MB</span></div>
<div class="line">                5                   <span class="comment">// 5 files</span></div>
<div class="line">            ),</div>
<div class="line">            std::make_unique&lt;timestamp_formatter&gt;()</div>
<div class="line">        ),</div>
<div class="line">        log_level::warn</div>
<div class="line">    ))</div>
<div class="line">    .build();</div>
</div><!-- fragment --><p><b>Characteristics:</b></p><ul>
<li><b>Throughput:</b> 300K msg/sec (blocking file I/O)</li>
<li><b>Latency:</b> 3µs (file write)</li>
<li><b>Memory:</b> Minimal (~2KB)</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md2774"></a>
Pattern 4: High-Throughput Production</h2>
<p><b>Stack:</b> </p><div class="fragment"><div class="line">filtered_writer (INFO+)</div>
<div class="line">  └─ formatted_writer (JSON)</div>
<div class="line">      └─ async_writer</div>
<div class="line">          └─ batch_writer (100 messages)</div>
<div class="line">              └─ buffered_writer (64KB)</div>
<div class="line">                  └─ rotating_file_writer</div>
</div><!-- fragment --><p><b>Use Case:</b> Production high-traffic services</p>
<p><b>Code:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> logger = logger_builder::create()</div>
<div class="line">    .with_writer(std::make_unique&lt;filtered_writer&gt;(</div>
<div class="line">        std::make_unique&lt;formatted_writer&gt;(</div>
<div class="line">            std::make_unique&lt;async_writer&gt;(</div>
<div class="line">                std::make_unique&lt;batch_writer&gt;(</div>
<div class="line">                    std::make_unique&lt;buffered_writer&gt;(</div>
<div class="line">                        std::make_unique&lt;rotating_file_writer&gt;(</div>
<div class="line">                            <span class="stringliteral">&quot;/var/log/app/app.log&quot;</span>,</div>
<div class="line">                            100 * 1024 * 1024,  <span class="comment">// 100MB</span></div>
<div class="line">                            10                   <span class="comment">// 10 files</span></div>
<div class="line">                        ),</div>
<div class="line">                        65536  <span class="comment">// 64KB buffer</span></div>
<div class="line">                    ),</div>
<div class="line">                    200  <span class="comment">// batch size</span></div>
<div class="line">                ),</div>
<div class="line">                50000  <span class="comment">// queue size</span></div>
<div class="line">            ),</div>
<div class="line">            std::make_unique&lt;json_formatter&gt;()</div>
<div class="line">        ),</div>
<div class="line">        log_level::info</div>
<div class="line">    ))</div>
<div class="line">    .build();</div>
</div><!-- fragment --><p><b>Characteristics:</b></p><ul>
<li><b>Throughput:</b> 4.34M msg/sec</li>
<li><b>Latency:</b> 148ns (non-blocking)</li>
<li><b>Memory:</b> Queue (50K × 200B = 10MB) + Buffer (64KB) = ~10MB</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md2776"></a>
Pattern 5: Encrypted Compliance Logging</h2>
<p><b>Stack:</b> </p><div class="fragment"><div class="line">filtered_writer (WARN+)</div>
<div class="line">  └─ formatted_writer (JSON + timestamp)</div>
<div class="line">      └─ encrypted_writer (AES-256-GCM)</div>
<div class="line">          └─ thread_safe_writer</div>
<div class="line">              └─ file_writer</div>
</div><!-- fragment --><p><b>Use Case:</b> HIPAA/GDPR compliance, secure audit logs</p>
<p><b>Code:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> key = secure_key_storage::load_key(<span class="stringliteral">&quot;/etc/keys/log_key.bin&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> logger = logger_builder::create()</div>
<div class="line">    .with_writer(std::make_unique&lt;filtered_writer&gt;(</div>
<div class="line">        std::make_unique&lt;formatted_writer&gt;(</div>
<div class="line">            std::make_unique&lt;encrypted_writer&gt;(</div>
<div class="line">                std::make_unique&lt;thread_safe_writer&gt;(</div>
<div class="line">                    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;/var/log/audit/secure.log&quot;</span>)</div>
<div class="line">                ),</div>
<div class="line">                key</div>
<div class="line">            ),</div>
<div class="line">            std::make_unique&lt;json_formatter&gt;()</div>
<div class="line">        ),</div>
<div class="line">        log_level::warn</div>
<div class="line">    ))</div>
<div class="line">    .build();</div>
</div><!-- fragment --><p><b>Characteristics:</b></p><ul>
<li><b>Throughput:</b> 200K msg/sec (encryption overhead)</li>
<li><b>Latency:</b> 5µs (blocking encryption + file I/O)</li>
<li><b>Memory:</b> Minimal (~3KB + key)</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md2778"></a>
Pattern 6: Multi-Destination (File + Network)</h2>
<p><b>Stack:</b> </p><div class="fragment"><div class="line">composite_writer</div>
<div class="line">  ├─ filtered(INFO+) → formatted(JSON) → rotating_file_writer</div>
<div class="line">  └─ filtered(ERROR+) → formatted(JSON) → async → network_writer</div>
</div><!-- fragment --><p><b>Use Case:</b> Local file + remote alerting</p>
<p><b>Code:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> composite = std::make_unique&lt;composite_writer&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Local file: all INFO+</span></div>
<div class="line">composite-&gt;add_writer(std::make_unique&lt;filtered_writer&gt;(</div>
<div class="line">    std::make_unique&lt;formatted_writer&gt;(</div>
<div class="line">        std::make_unique&lt;rotating_file_writer&gt;(<span class="stringliteral">&quot;/var/log/app/app.log&quot;</span>),</div>
<div class="line">        std::make_unique&lt;json_formatter&gt;()</div>
<div class="line">    ),</div>
<div class="line">    log_level::info</div>
<div class="line">));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Remote server: only ERROR+</span></div>
<div class="line">composite-&gt;add_writer(std::make_unique&lt;filtered_writer&gt;(</div>
<div class="line">    std::make_unique&lt;formatted_writer&gt;(</div>
<div class="line">        std::make_unique&lt;async_writer&gt;(</div>
<div class="line">            std::make_unique&lt;network_writer&gt;(<span class="stringliteral">&quot;logs.example.com&quot;</span>, 5140)</div>
<div class="line">        ),</div>
<div class="line">        std::make_unique&lt;json_formatter&gt;()</div>
<div class="line">    ),</div>
<div class="line">    log_level::error</div>
<div class="line">));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> logger = logger_builder::create()</div>
<div class="line">    .with_writer(std::move(composite))</div>
<div class="line">    .build();</div>
</div><!-- fragment --><p><b>Characteristics:</b></p><ul>
<li><b>Throughput:</b> 1.5M msg/sec (file path limits)</li>
<li><b>Latency:</b> 3µs (file write, network async)</li>
<li><b>Memory:</b> ~12MB (network queue)</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md2780"></a>
Recommended Stacks</h1>
<h2><a class="anchor" id="autotoc_md2781"></a>
Development</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Use Case   </th><th class="markdownTableHeadNone">Stack (inner → outer)   </th><th class="markdownTableHeadNone">Throughput   </th><th class="markdownTableHeadNone">Latency   </th><th class="markdownTableHeadNone">Memory    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Quick debugging</b>   </td><td class="markdownTableBodyNone"><code>console</code>   </td><td class="markdownTableBodyNone">500K msg/s   </td><td class="markdownTableBodyNone">2µs   </td><td class="markdownTableBodyNone">1KB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>High-volume dev</b>   </td><td class="markdownTableBodyNone"><code>async</code> → <code>console</code>   </td><td class="markdownTableBodyNone">4.3M msg/s   </td><td class="markdownTableBodyNone">148ns   </td><td class="markdownTableBodyNone">2MB    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Formatted console</b>   </td><td class="markdownTableBodyNone"><code>formatted</code> → <code>console</code>   </td><td class="markdownTableBodyNone">300K msg/s   </td><td class="markdownTableBodyNone">3µs   </td><td class="markdownTableBodyNone">1KB   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2782"></a>
Production File Logging</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Use Case   </th><th class="markdownTableHeadNone">Stack (inner → outer)   </th><th class="markdownTableHeadNone">Throughput   </th><th class="markdownTableHeadNone">Latency   </th><th class="markdownTableHeadNone">Memory    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Simple file</b>   </td><td class="markdownTableBodyNone"><code>file</code>   </td><td class="markdownTableBodyNone">300K msg/s   </td><td class="markdownTableBodyNone">3µs   </td><td class="markdownTableBodyNone">2KB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Rotating file</b>   </td><td class="markdownTableBodyNone"><code>rotating_file</code>   </td><td class="markdownTableBodyNone">300K msg/s   </td><td class="markdownTableBodyNone">3µs   </td><td class="markdownTableBodyNone">2KB    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>High-throughput</b>   </td><td class="markdownTableBodyNone"><code>rotating_file</code> → <code>buffered</code> → <code>batch</code> → <code>async</code> → <code>formatted</code> → <code>filtered</code>   </td><td class="markdownTableBodyNone">4.34M msg/s   </td><td class="markdownTableBodyNone">148ns   </td><td class="markdownTableBodyNone">10MB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>JSON logs</b>   </td><td class="markdownTableBodyNone"><code>rotating_file</code> → <code>formatted(JSON)</code>   </td><td class="markdownTableBodyNone">200K msg/s   </td><td class="markdownTableBodyNone">5µs   </td><td class="markdownTableBodyNone">2KB   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2783"></a>
Compliance &amp; Security</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Use Case   </th><th class="markdownTableHeadNone">Stack (inner → outer)   </th><th class="markdownTableHeadNone">Throughput   </th><th class="markdownTableHeadNone">Latency   </th><th class="markdownTableHeadNone">Memory    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Encrypted logs</b>   </td><td class="markdownTableBodyNone"><code>file</code> → <code>encrypted</code> → <code>formatted</code> → <code>filtered</code>   </td><td class="markdownTableBodyNone">200K msg/s   </td><td class="markdownTableBodyNone">5µs   </td><td class="markdownTableBodyNone">3KB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Audit trail</b>   </td><td class="markdownTableBodyNone"><code>file</code> → <code>critical</code> → <code>encrypted</code> → <code>formatted</code>   </td><td class="markdownTableBodyNone">150K msg/s   </td><td class="markdownTableBodyNone">7µs   </td><td class="markdownTableBodyNone">3KB    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Tamper-evident</b>   </td><td class="markdownTableBodyNone"><code>rotating_file</code> → <code>encrypted</code> → <code>batch</code> → <code>async</code> → <code>formatted</code>   </td><td class="markdownTableBodyNone">1M msg/s   </td><td class="markdownTableBodyNone">500ns   </td><td class="markdownTableBodyNone">12MB   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2784"></a>
Distributed Systems</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Use Case   </th><th class="markdownTableHeadNone">Stack (inner → outer)   </th><th class="markdownTableHeadNone">Throughput   </th><th class="markdownTableHeadNone">Latency   </th><th class="markdownTableHeadNone">Memory    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Remote logging</b>   </td><td class="markdownTableBodyNone"><code>network</code> → <code>async</code> → <code>formatted</code> → <code>filtered</code>   </td><td class="markdownTableBodyNone">1.5M msg/s   </td><td class="markdownTableBodyNone">200ns   </td><td class="markdownTableBodyNone">12MB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>OTLP export</b>   </td><td class="markdownTableBodyNone"><code>otlp</code> → <code>async</code> → <code>batch</code>   </td><td class="markdownTableBodyNone">2M msg/s   </td><td class="markdownTableBodyNone">180ns   </td><td class="markdownTableBodyNone">15MB    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Multi-destination</b>   </td><td class="markdownTableBodyNone"><code>composite(file + network)</code> → <code>async</code> → <code>formatted</code>   </td><td class="markdownTableBodyNone">1.5M msg/s   </td><td class="markdownTableBodyNone">200ns   </td><td class="markdownTableBodyNone">12MB   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2785"></a>
Resource-Constrained</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Use Case   </th><th class="markdownTableHeadNone">Stack (inner → outer)   </th><th class="markdownTableHeadNone">Throughput   </th><th class="markdownTableHeadNone">Latency   </th><th class="markdownTableHeadNone">Memory    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Minimal memory</b>   </td><td class="markdownTableBodyNone"><code>console</code> → <code>filtered(ERROR+)</code>   </td><td class="markdownTableBodyNone">500K msg/s   </td><td class="markdownTableBodyNone">2µs   </td><td class="markdownTableBodyNone">1KB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Low CPU</b>   </td><td class="markdownTableBodyNone"><code>file</code> → <code>filtered(WARN+)</code>   </td><td class="markdownTableBodyNone">300K msg/s   </td><td class="markdownTableBodyNone">3µs   </td><td class="markdownTableBodyNone">2KB    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Embedded</b>   </td><td class="markdownTableBodyNone"><code>file</code> → <code>filtered</code> (no formatting)   </td><td class="markdownTableBodyNone">400K msg/s   </td><td class="markdownTableBodyNone">2.5µs   </td><td class="markdownTableBodyNone">1.5KB   </td></tr>
</table>
<hr  />
<h1><a class="anchor" id="autotoc_md2787"></a>
Code Examples</h1>
<h2><a class="anchor" id="autotoc_md2788"></a>
Example 1: Development Setup (3 lines)</h2>
<div class="fragment"><div class="line"><span class="keyword">auto</span> logger = logger_builder::create()</div>
<div class="line">    .with_console_writer()</div>
<div class="line">    .build();</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md2790"></a>
Example 2: Production File Logging</h2>
<div class="fragment"><div class="line"><span class="keyword">auto</span> logger = logger_builder::create()</div>
<div class="line">    .with_writer(std::make_unique&lt;async_writer&gt;(</div>
<div class="line">        std::make_unique&lt;batch_writer&gt;(</div>
<div class="line">            std::make_unique&lt;buffered_writer&gt;(</div>
<div class="line">                std::make_unique&lt;rotating_file_writer&gt;(</div>
<div class="line">                    <span class="stringliteral">&quot;/var/log/app/app.log&quot;</span>,</div>
<div class="line">                    100 * 1024 * 1024,  <span class="comment">// 100MB per file</span></div>
<div class="line">                    10                   <span class="comment">// keep 10 files</span></div>
<div class="line">                ),</div>
<div class="line">                65536  <span class="comment">// 64KB buffer</span></div>
<div class="line">            ),</div>
<div class="line">            200,  <span class="comment">// batch 200 messages</span></div>
<div class="line">            std::chrono::milliseconds(500)  <span class="comment">// or 500ms timeout</span></div>
<div class="line">        ),</div>
<div class="line">        50000  <span class="comment">// queue size</span></div>
<div class="line">    ))</div>
<div class="line">    .build();</div>
<div class="line"> </div>
<div class="line">logger-&gt;info(<span class="stringliteral">&quot;Application started&quot;</span>);</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md2792"></a>
Example 3: Encrypted Compliance Logging</h2>
<div class="fragment"><div class="line"><span class="comment">// Generate or load encryption key</span></div>
<div class="line"><span class="keyword">auto</span> key_result = secure_key_storage::load_key(</div>
<div class="line">    <span class="stringliteral">&quot;/etc/keys/log_encryption.key&quot;</span>,</div>
<div class="line">    32,  <span class="comment">// AES-256</span></div>
<div class="line">    <span class="stringliteral">&quot;/etc/keys&quot;</span>  <span class="comment">// allowed base directory</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (key_result.is_err()) {</div>
<div class="line">    <span class="comment">// Handle error</span></div>
<div class="line">}</div>
<div class="line"><span class="keyword">auto</span> key = std::move(key_result).unwrap();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Build encrypted logger</span></div>
<div class="line"><span class="keyword">auto</span> logger = logger_builder::create()</div>
<div class="line">    .with_writer(std::make_unique&lt;filtered_writer&gt;(</div>
<div class="line">        std::make_unique&lt;formatted_writer&gt;(</div>
<div class="line">            std::make_unique&lt;encrypted_writer&gt;(</div>
<div class="line">                std::make_unique&lt;critical_writer&gt;(</div>
<div class="line">                    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;/var/log/audit/secure.log&quot;</span>),</div>
<div class="line">                    log_level::warn  <span class="comment">// immediate flush on WARN+</span></div>
<div class="line">                ),</div>
<div class="line">                key</div>
<div class="line">            ),</div>
<div class="line">            std::make_unique&lt;json_formatter&gt;()</div>
<div class="line">        ),</div>
<div class="line">        log_level::warn  <span class="comment">// only WARN+</span></div>
<div class="line">    ))</div>
<div class="line">    .build();</div>
<div class="line"> </div>
<div class="line">logger-&gt;warn(<span class="stringliteral">&quot;User authentication failed&quot;</span>, {{<span class="stringliteral">&quot;user_id&quot;</span>, <span class="stringliteral">&quot;12345&quot;</span>}});</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md2794"></a>
Example 4: Multi-Destination Setup</h2>
<div class="fragment"><div class="line"><span class="keyword">auto</span> composite = std::make_unique&lt;composite_writer&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Destination 1: Local file (all logs)</span></div>
<div class="line">composite-&gt;add_writer(std::make_unique&lt;formatted_writer&gt;(</div>
<div class="line">    std::make_unique&lt;rotating_file_writer&gt;(</div>
<div class="line">        <span class="stringliteral">&quot;/var/log/app/app.log&quot;</span>,</div>
<div class="line">        50 * 1024 * 1024,</div>
<div class="line">        5</div>
<div class="line">    ),</div>
<div class="line">    std::make_unique&lt;timestamp_formatter&gt;()</div>
<div class="line">));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Destination 2: Remote server (errors only)</span></div>
<div class="line">composite-&gt;add_writer(std::make_unique&lt;filtered_writer&gt;(</div>
<div class="line">    std::make_unique&lt;formatted_writer&gt;(</div>
<div class="line">        std::make_unique&lt;async_writer&gt;(</div>
<div class="line">            std::make_unique&lt;network_writer&gt;(<span class="stringliteral">&quot;logs.example.com&quot;</span>, 5140)</div>
<div class="line">        ),</div>
<div class="line">        std::make_unique&lt;json_formatter&gt;()</div>
<div class="line">    ),</div>
<div class="line">    log_level::error</div>
<div class="line">));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Destination 3: OTLP (OpenTelemetry)</span></div>
<div class="line">composite-&gt;add_writer(std::make_unique&lt;async_writer&gt;(</div>
<div class="line">    std::make_unique&lt;otlp_writer&gt;(<span class="stringliteral">&quot;http://otel-collector:4317&quot;</span>)</div>
<div class="line">));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> logger = logger_builder::create()</div>
<div class="line">    .with_writer(std::move(composite))</div>
<div class="line">    .build();</div>
<div class="line"> </div>
<div class="line">logger-&gt;error(<span class="stringliteral">&quot;Database connection failed&quot;</span>, {{<span class="stringliteral">&quot;db&quot;</span>, <span class="stringliteral">&quot;primary&quot;</span>}});</div>
<div class="line"><span class="comment">// → Written to: file, network, OTLP</span></div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md2796"></a>
Example 5: Custom Stack Order</h2>
<div class="fragment"><div class="line"><span class="comment">// Optimal stack order: filter → format → async → batch → buffer → file</span></div>
<div class="line"><span class="keyword">auto</span> logger = logger_builder::create()</div>
<div class="line">    .with_writer(</div>
<div class="line">        std::make_unique&lt;filtered_writer&gt;(        <span class="comment">// 1. Filter first (drop early)</span></div>
<div class="line">            std::make_unique&lt;formatted_writer&gt;(    <span class="comment">// 2. Format (before async to avoid re-formatting)</span></div>
<div class="line">                std::make_unique&lt;async_writer&gt;(    <span class="comment">// 3. Async (non-blocking from here)</span></div>
<div class="line">                    std::make_unique&lt;batch_writer&gt;( <span class="comment">// 4. Batch (accumulate)</span></div>
<div class="line">                        std::make_unique&lt;buffered_writer&gt;( <span class="comment">// 5. Buffer (reduce syscalls)</span></div>
<div class="line">                            std::make_unique&lt;rotating_file_writer&gt;( <span class="comment">// 6. Base writer</span></div>
<div class="line">                                <span class="stringliteral">&quot;/var/log/app/app.log&quot;</span></div>
<div class="line">                            )</div>
<div class="line">                        )</div>
<div class="line">                    )</div>
<div class="line">                ),</div>
<div class="line">                std::make_unique&lt;json_formatter&gt;()</div>
<div class="line">            ),</div>
<div class="line">            log_level::info</div>
<div class="line">        )</div>
<div class="line">    )</div>
<div class="line">    .build();</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md2798"></a>
Performance Impact</h1>
<h2><a class="anchor" id="autotoc_md2799"></a>
Throughput per Configuration</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Configuration   </th><th class="markdownTableHeadNone">Throughput   </th><th class="markdownTableHeadNone">Baseline %    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Baseline (console only)</b>   </td><td class="markdownTableBodyNone">500K msg/s   </td><td class="markdownTableBodyNone">100%    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">+ async   </td><td class="markdownTableBodyNone">4.3M msg/s   </td><td class="markdownTableBodyNone">860%    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">+ async + batch   </td><td class="markdownTableBodyNone">4.34M msg/s   </td><td class="markdownTableBodyNone">868%    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">+ async + batch + buffer   </td><td class="markdownTableBodyNone">4.34M msg/s   </td><td class="markdownTableBodyNone">868% (I/O limited)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">+ async + batch + buffer + filter   </td><td class="markdownTableBodyNone">4.34M msg/s   </td><td class="markdownTableBodyNone">868% (drops early)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">+ async + batch + buffer + formatted   </td><td class="markdownTableBodyNone">3.8M msg/s   </td><td class="markdownTableBodyNone">760% (CPU overhead)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">+ encrypted   </td><td class="markdownTableBodyNone">1.5M msg/s   </td><td class="markdownTableBodyNone">300% (crypto overhead)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">+ network (TCP)   </td><td class="markdownTableBodyNone">1.2M msg/s   </td><td class="markdownTableBodyNone">240% (network I/O)   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2800"></a>
Latency per Decorator</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Decorator   </th><th class="markdownTableHeadNone">Latency Added   </th><th class="markdownTableHeadNone">Cumulative    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Base (console)</b>   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">2µs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">+ filtered   </td><td class="markdownTableBodyNone">+5ns   </td><td class="markdownTableBodyNone">2.005µs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">+ formatted   </td><td class="markdownTableBodyNone">+50ns   </td><td class="markdownTableBodyNone">2.055µs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">+ async (enqueue)   </td><td class="markdownTableBodyNone">+30ns   </td><td class="markdownTableBodyNone">2.085µs → <b>148ns</b> (non-blocking)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">+ batch (enqueue)   </td><td class="markdownTableBodyNone">+10ns   </td><td class="markdownTableBodyNone">158ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">+ buffered   </td><td class="markdownTableBodyNone">+5ns   </td><td class="markdownTableBodyNone">163ns    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">+ thread_safe (mutex)   </td><td class="markdownTableBodyNone">+100ns   </td><td class="markdownTableBodyNone">263ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">+ encrypted   </td><td class="markdownTableBodyNone">+300ns   </td><td class="markdownTableBodyNone">563ns   </td></tr>
</table>
<p><b>Note:</b> <code>async_writer</code> makes subsequent latencies invisible to the caller (background processing).</p>
<h2><a class="anchor" id="autotoc_md2801"></a>
Memory Usage per Decorator</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Decorator   </th><th class="markdownTableHeadNone">Memory Usage   </th><th class="markdownTableHeadNone">Notes    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Base writers</b>   </td><td class="markdownTableBodyNone">1-2KB   </td><td class="markdownTableBodyNone">Minimal overhead    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">async_writer   </td><td class="markdownTableBodyNone">Queue size × 200B   </td><td class="markdownTableBodyNone">Default: 10K × 200B = 2MB    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">batch_writer   </td><td class="markdownTableBodyNone">Batch size × 200B   </td><td class="markdownTableBodyNone">Default: 100 × 200B = 20KB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">buffered_writer   </td><td class="markdownTableBodyNone">Buffer size   </td><td class="markdownTableBodyNone">Default: 64KB    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">composite_writer   </td><td class="markdownTableBodyNone">N × child memory   </td><td class="markdownTableBodyNone">Linear with child count    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">encrypted_writer   </td><td class="markdownTableBodyNone">32B (key) + 16B (IV)   </td><td class="markdownTableBodyNone">Per message    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">formatted_writer   </td><td class="markdownTableBodyNone">Formatted string size   </td><td class="markdownTableBodyNone">Transient (released after write)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">filtered_writer   </td><td class="markdownTableBodyNone">Negligible   </td><td class="markdownTableBodyNone">No buffering    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">thread_safe_writer   </td><td class="markdownTableBodyNone">64B (mutex)   </td><td class="markdownTableBodyNone">Minimal   </td></tr>
</table>
<p><b>Example:</b> High-throughput stack memory: </p><div class="fragment"><div class="line">async (2MB) + batch (20KB) + buffered (64KB) + base (2KB) = ~2.1MB</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md2803"></a>
Best Practices</h1>
<h2><a class="anchor" id="autotoc_md2804"></a>
1. Filter Early, Format Late</h2>
<p>✅ <b>Good:</b> </p><div class="fragment"><div class="line">filtered → formatted → async → file</div>
</div><!-- fragment --><p>❌ <b>Bad:</b> </p><div class="fragment"><div class="line">async → formatted → filtered → file  <span class="comment">// Wastes formatting on filtered messages</span></div>
</div><!-- fragment --><p><b>Rationale:</b> Filtering is cheap (5ns), formatting is expensive (50-100ns). Drop messages before formatting.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md2806"></a>
2. Use Async for I/O-Heavy Writers</h2>
<p>✅ <b>Good:</b> </p><div class="fragment"><div class="line">async → file  <span class="comment">// File I/O is slow (3µs)</span></div>
<div class="line">async → network  <span class="comment">// Network I/O is slow (1-10ms)</span></div>
</div><!-- fragment --><p>❌ <b>Bad:</b> </p><div class="fragment"><div class="line">console  <span class="comment">// Blocking I/O without async</span></div>
</div><!-- fragment --><p><b>Rationale:</b> I/O operations block the caller. Use <code>async_writer</code> to make writes non-blocking.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md2808"></a>
3. Batch + Buffer for Maximum Throughput</h2>
<p>✅ <b>Good:</b> </p><div class="fragment"><div class="line">async → batch → buffered → file  <span class="comment">// Reduces syscalls</span></div>
</div><!-- fragment --><p>❌ <b>Bad:</b> </p><div class="fragment"><div class="line">async → file  <span class="comment">// Many small writes (syscall overhead)</span></div>
</div><!-- fragment --><p><b>Rationale:</b> Batching reduces syscall count, buffering reduces disk I/O. Combine both for maximum throughput.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md2810"></a>
4. Encrypt Only What's Necessary</h2>
<p>✅ <b>Good:</b> </p><div class="fragment"><div class="line">composite {</div>
<div class="line">    file (all logs, unencrypted),</div>
<div class="line">    encrypted → file (sensitive logs only)</div>
<div class="line">}</div>
</div><!-- fragment --><p>❌ <b>Bad:</b> </p><div class="fragment"><div class="line">encrypted → file (all logs)  <span class="comment">// Wastes CPU on non-sensitive logs</span></div>
</div><!-- fragment --><p><b>Rationale:</b> Encryption is expensive (30-40% throughput reduction). Encrypt only sensitive logs.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md2812"></a>
5. Use &lt;tt&gt;composite_writer&lt;/tt&gt; for Multi-Destination</h2>
<p>✅ <b>Good:</b> </p><div class="fragment"><div class="line">composite { file, network }</div>
</div><!-- fragment --><p>❌ <b>Bad:</b> </p><div class="fragment"><div class="line"><span class="comment">// Create two separate loggers</span></div>
<div class="line">logger1-&gt;write(...);  <span class="comment">// file</span></div>
<div class="line">logger2-&gt;write(...);  <span class="comment">// network</span></div>
</div><!-- fragment --><p><b>Rationale:</b> <code>composite_writer</code> writes to all destinations in a single call, ensuring consistency.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md2814"></a>
6. Flush on Critical Logs</h2>
<p>✅ <b>Good:</b> </p><div class="fragment"><div class="line">critical_writer(file, log_level::fatal)  <span class="comment">// Immediate flush on FATAL</span></div>
</div><!-- fragment --><p>❌ <b>Bad:</b> </p><div class="fragment"><div class="line">async → batch → file  <span class="comment">// Critical logs may be lost in queue/batch on crash</span></div>
</div><!-- fragment --><p><b>Rationale:</b> Critical logs must be persisted immediately. Use <code>critical_writer</code> to force flush.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md2816"></a>
7. Thread-Safety Only When Needed</h2>
<p>✅ <b>Good:</b> </p><div class="fragment"><div class="line"><span class="comment">// Logger is thread-safe internally, no need for thread_safe_writer</span></div>
<div class="line">async → file</div>
</div><!-- fragment --><p>❌ <b>Bad:</b> </p><div class="fragment"><div class="line">thread_safe → async → file  <span class="comment">// Redundant: async already thread-safe</span></div>
</div><!-- fragment --><p><b>Rationale:</b> Most decorators are already thread-safe. Only use <code>thread_safe_writer</code> for custom non-thread-safe writers.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md2818"></a>
8. Start Async Writers Explicitly</h2>
<p>✅ <b>Good:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> async = std::make_unique&lt;async_writer&gt;(...);</div>
<div class="line">async-&gt;start();  <span class="comment">// Start background thread</span></div>
<div class="line"><span class="keyword">auto</span> logger = logger_builder::create().with_writer(std::move(async)).build();</div>
</div><!-- fragment --><p>❌ <b>Bad:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> logger = logger_builder::create()</div>
<div class="line">    .with_writer(std::make_unique&lt;async_writer&gt;(...))</div>
<div class="line">    .build();</div>
<div class="line"><span class="comment">// Forgot to call start()!</span></div>
</div><!-- fragment --><p><b>Rationale:</b> <code>async_writer</code> requires explicit <code>start()</code> to begin processing.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md2820"></a>
Summary</h1>
<p>The <b>logger_system writer framework</b> provides:</p>
<ul>
<li>✅ <b>18 writer types</b> — 5 base writers + 13 decorators</li>
<li>✅ <b>Decorator pattern</b> — Unlimited composition and stacking</li>
<li>✅ <b>High performance</b> — 4.34M msg/sec, 148ns latency</li>
<li>✅ <b>Flexible pipelines</b> — Filter, format, batch, buffer, encrypt, fan-out</li>
<li>✅ <b>Production-ready</b> — Thread-safe, async, rotating, encrypted</li>
</ul>
<p><b>Quick reference:</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Task   </th><th class="markdownTableHeadNone">Recommended Stack    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Development   </td><td class="markdownTableBodyNone"><code>console</code> or <code>async → console</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Production file   </td><td class="markdownTableBodyNone"><code>rotating_file → buffered → batch → async → formatted → filtered</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Compliance   </td><td class="markdownTableBodyNone"><code>file → encrypted → critical → formatted → filtered</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Distributed   </td><td class="markdownTableBodyNone"><code>network → async → batch → formatted → filtered</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Multi-destination   </td><td class="markdownTableBodyNone"><code>composite(file + network) → async → formatted</code>   </td></tr>
</table>
<p><b>Next steps:</b></p><ul>
<li>Review <a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2ARCHITECTURE.html">ARCHITECTURE.md</a> for logger architecture</li>
<li>Review <a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2SECURITY__GUIDE.html">SECURITY_GUIDE.md</a> for encryption details</li>
<li>Review <a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2CONFIGURATION__STRATEGIES.html">CONFIGURATION_STRATEGIES.md</a> for environment-based config</li>
</ul>
<hr  />
<p><em>Last updated: 2025-02-09</em> <em>logger_system version: 2.x</em> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Feb 11 2026 23:47:05 for Logger System by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
