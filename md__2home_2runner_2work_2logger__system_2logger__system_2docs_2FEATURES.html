<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Logger System: Logger System Features</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Logger System<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-performance C++20 thread-safe logging system with asynchronous capabilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__2home_2runner_2work_2logger__system_2logger__system_2docs_2FEATURES.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Logger System Features</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md1244"></a> <b>Last Updated</b>: 2025-11-15 <b>Version</b>: 0.3.0.0</p>
<p>This document provides comprehensive details about all features available in the logger system.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md1246"></a>
Table of Contents</h1>
<ul>
<li>Core Features</li>
<li>Writer Types</li>
<li>Formatting Options</li>
<li>Filtering Capabilities</li>
<li>Rotation Policies</li>
<li>Security Features</li>
<li>Advanced Capabilities</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md1248"></a>
Core Features</h1>
<h2><a class="anchor" id="autotoc_md1249"></a>
üéØ High-Performance Logging</h2>
<h3><a class="anchor" id="autotoc_md1250"></a>
Asynchronous Processing</h3>
<ul>
<li><b>Non-blocking log operations</b>: Background thread processes log entries without blocking application threads</li>
<li><b>Batched queue processing</b>: Processes multiple log entries efficiently to maximize throughput</li>
<li><b>Configurable batching</b>: Tunable batch sizes and queue depths for optimal throughput</li>
<li><b>Zero-copy design</b>: Efficient message passing with minimal allocations</li>
<li><b>Adaptive queuing</b>: Intelligent backoff and batching strategies for optimal resource utilization</li>
</ul>
<p><b>Performance Metrics</b>:</p><ul>
<li>Peak throughput: 4.34M messages/second (single thread, async mode)</li>
<li>Average enqueue time: 148 nanoseconds</li>
<li>Memory efficiency: &lt;2MB baseline with adaptive buffer management</li>
</ul>
<h3><a class="anchor" id="autotoc_md1251"></a>
Thread-Safe Operations</h3>
<ul>
<li>**Concurrent logging**: Safe logging from multiple threads without locks on hot path</li>
<li>**Writer thread safety**: All writer implementations verified for concurrent access</li>
<li>**ThreadSanitizer compliance**: Zero data races detected in CI/CD pipeline</li>
<li>**Perfect RAII compliance**: 100% smart pointer usage, zero memory leaks</li>
</ul>
<h3><a class="anchor" id="autotoc_md1252"></a>
Configuration Validation</h3>
<ul>
<li>**Comprehensive validation**: Configuration validation with meaningful error messages</li>
<li>**Builder pattern**: Fluent API for logger construction with validation</li>
<li>**Template-based configurations**: Predefined configurations for common scenarios</li>
<li>**Error handling**: Result pattern ensures no silent failures</li>
</ul>
<h2><a class="anchor" id="autotoc_md1253"></a>
üîß Advanced Capabilities</h2>
<h3><a class="anchor" id="autotoc_md1254"></a>
Result-Based Error Handling</h3>
<ul>
<li>**Result&lt;T&gt; pattern**: Type-safe error handling without exceptions</li>
<li><b>Comprehensive error codes</b>: Allocated range -200 to -299 in centralized error code registry</li>
<li><b>Meaningful error messages</b>: Comprehensive error context with validation details</li>
<li><b>Dual API design</b>: Balance between comprehensive error reporting and high-performance logging</li>
</ul>
<h3><a class="anchor" id="autotoc_md1255"></a>
Builder Pattern API</h3>
<ul>
<li><b>Fluent interface</b>: Type-safe logger construction with method chaining</li>
<li><b>Automatic validation</b>: Configuration validation during build process</li>
<li><b>Template support</b>: Use predefined templates or customize all parameters</li>
<li><b>Dependency injection</b>: Optional runtime component injection with fallback mechanisms</li>
</ul>
<h3><a class="anchor" id="autotoc_md1256"></a>
Configuration Strategies</h3>
<ul>
<li><b>Production template</b>: Optimized for production environments with balanced performance</li>
<li><b>Debug template</b>: Immediate output for development with detailed logging</li>
<li><b>High-performance template</b>: Maximized throughput for high-load scenarios</li>
<li><b>Low-latency template</b>: Minimized latency for real-time systems</li>
</ul>
<h3><a class="anchor" id="autotoc_md1257"></a>
Monitoring Integration</h3>
<ul>
<li><b>Pluggable monitoring</b>: Optional IMonitor interface integration</li>
<li><b>Health checks</b>: Built-in health check endpoints</li>
<li><b>Performance metrics</b>: Real-time metrics collection and reporting</li>
<li><b>Queue utilization</b>: Automatic optimization maintains high throughput</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md1259"></a>
Writer Types</h1>
<h2><a class="anchor" id="autotoc_md1260"></a>
Console Writer</h2>
<p><b>Features</b>:</p><ul>
<li>ANSI colored output for different log levels</li>
<li>Cross-platform support (Windows, Linux, macOS)</li>
<li>Configurable color schemes</li>
<li>Thread-safe concurrent output</li>
</ul>
<p><b>Usage</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/console_writer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> logger = kcenon::logger::logger_builder()</div>
<div class="line">    .add_writer(<span class="stringliteral">&quot;console&quot;</span>, std::make_unique&lt;kcenon::logger::console_writer&gt;())</div>
<div class="line">    .build()</div>
<div class="line">    .value();</div>
</div><!-- fragment --><p><b>Configuration Options</b>:</p><ul>
<li>Color enabled/disabled</li>
<li>Custom color schemes for different log levels</li>
<li>Stdout/stderr routing based on log level</li>
</ul>
<h2><a class="anchor" id="autotoc_md1261"></a>
File Writer</h2>
<p><b>Features</b>:</p><ul>
<li>Buffered file output for performance</li>
<li>Automatic file creation and directory creation</li>
<li>Configurable buffer sizes</li>
<li>Thread-safe file access</li>
</ul>
<p><b>Usage</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/file_writer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> logger = kcenon::logger::logger_builder()</div>
<div class="line">    .add_writer(<span class="stringliteral">&quot;file&quot;</span>, std::make_unique&lt;kcenon::logger::file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>))</div>
<div class="line">    .build()</div>
<div class="line">    .value();</div>
</div><!-- fragment --><p><b>Configuration Options</b>:</p><ul>
<li>Buffer size (default: 8KB)</li>
<li>Flush interval</li>
<li>File permissions (default: 0600 - owner read/write only)</li>
<li>Append/overwrite mode</li>
</ul>
<h2><a class="anchor" id="autotoc_md1262"></a>
Rotating File Writer</h2>
<p><b>Features</b>:</p><ul>
<li><b>Size-based rotation</b>: Automatically rotate when file reaches configured size</li>
<li><b>Time-based rotation</b>: Rotate daily, hourly, or at custom intervals</li>
<li><b>Backup file management</b>: Configurable number of backup files to keep</li>
<li><b>Automatic compression</b>: Optional gzip compression of rotated files</li>
<li><b>Thread-safe rotation</b>: Safe rotation during concurrent logging</li>
</ul>
<p><b>Size-Based Rotation</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/rotating_file_writer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Rotate when file reaches 10MB, keep 5 backup files</span></div>
<div class="line"><span class="keyword">auto</span> logger = kcenon::logger::logger_builder()</div>
<div class="line">    .add_writer(<span class="stringliteral">&quot;rotating&quot;</span>, std::make_unique&lt;kcenon::logger::rotating_file_writer&gt;(</div>
<div class="line">        <span class="stringliteral">&quot;logs/app.log&quot;</span>,</div>
<div class="line">        10 * 1024 * 1024,  <span class="comment">// 10MB per file</span></div>
<div class="line">        5                   <span class="comment">// Keep 5 backup files</span></div>
<div class="line">    ))</div>
<div class="line">    .build()</div>
<div class="line">    .value();</div>
</div><!-- fragment --><p><b>Time-Based Rotation</b>: </p><div class="fragment"><div class="line"><span class="comment">// Rotate daily, keep 30 days of logs</span></div>
<div class="line"><span class="keyword">auto</span> logger = kcenon::logger::logger_builder()</div>
<div class="line">    .add_writer(<span class="stringliteral">&quot;daily&quot;</span>, std::make_unique&lt;kcenon::logger::rotating_file_writer&gt;(</div>
<div class="line">        <span class="stringliteral">&quot;logs/daily.log&quot;</span>,</div>
<div class="line">        kcenon::logger::rotating_file_writer::rotation_type::daily,</div>
<div class="line">        30  <span class="comment">// Keep 30 days of logs</span></div>
<div class="line">    ))</div>
<div class="line">    .build()</div>
<div class="line">    .value();</div>
</div><!-- fragment --><p><b>Configuration Options</b>:</p><ul>
<li>Rotation policy: size-based, daily, hourly, weekly</li>
<li>Maximum file size (for size-based rotation)</li>
<li>Number of backup files to keep</li>
<li>Compression: none, gzip, bzip2</li>
<li>Naming pattern for rotated files</li>
</ul>
<h2><a class="anchor" id="autotoc_md1263"></a>
Network Writer</h2>
<p><b>Features</b>:</p><ul>
<li>TCP/UDP protocol support</li>
<li>Automatic reconnection on connection failure</li>
<li>Configurable retry strategies</li>
<li>Message batching for network efficiency</li>
</ul>
<p><b>TCP Network Writer</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/network_writer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> logger = kcenon::logger::logger_builder()</div>
<div class="line">    .add_writer(<span class="stringliteral">&quot;remote&quot;</span>, std::make_unique&lt;kcenon::logger::network_writer&gt;(</div>
<div class="line">        <span class="stringliteral">&quot;log-server.example.com&quot;</span>,</div>
<div class="line">        9999,</div>
<div class="line">        kcenon::logger::network_writer::protocol_type::tcp</div>
<div class="line">    ))</div>
<div class="line">    .build()</div>
<div class="line">    .value();</div>
</div><!-- fragment --><p><b>UDP Network Writer</b>: </p><div class="fragment"><div class="line"><span class="comment">// UDP for fire-and-forget logging (higher performance, no guarantees)</span></div>
<div class="line"><span class="keyword">auto</span> logger = kcenon::logger::logger_builder()</div>
<div class="line">    .add_writer(<span class="stringliteral">&quot;udp_remote&quot;</span>, std::make_unique&lt;kcenon::logger::network_writer&gt;(</div>
<div class="line">        <span class="stringliteral">&quot;log-collector.example.com&quot;</span>,</div>
<div class="line">        514,  <span class="comment">// Syslog port</span></div>
<div class="line">        kcenon::logger::network_writer::protocol_type::udp</div>
<div class="line">    ))</div>
<div class="line">    .build()</div>
<div class="line">    .value();</div>
</div><!-- fragment --><p><b>Configuration Options</b>:</p><ul>
<li>Protocol: TCP, UDP</li>
<li>Connection timeout</li>
<li>Retry attempts and backoff strategy</li>
<li>Message batching size</li>
<li>Compression</li>
</ul>
<h2><a class="anchor" id="autotoc_md1264"></a>
Critical Writer</h2>
<p><b>Features</b>:</p><ul>
<li><b>Synchronous logging</b>: Bypasses async queue for immediate writes</li>
<li><b>Guaranteed persistence</b>: File is updated before function returns</li>
<li><b>Crash-safe</b>: Ensures critical messages survive abnormal termination</li>
<li><b>Wrapper pattern</b>: Wraps any other writer for synchronous behavior</li>
</ul>
<p><b>Usage</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/critical_writer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/file_writer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a critical writer wrapping a file writer</span></div>
<div class="line"><span class="keyword">auto</span> critical = std::make_unique&lt;kcenon::logger::critical_writer&gt;(</div>
<div class="line">    std::make_unique&lt;kcenon::logger::file_writer&gt;(<span class="stringliteral">&quot;critical.log&quot;</span>)</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> logger = kcenon::logger::logger_builder()</div>
<div class="line">    .add_writer(<span class="stringliteral">&quot;critical&quot;</span>, std::move(critical))</div>
<div class="line">    .build()</div>
<div class="line">    .value();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This log is written immediately, not queued</span></div>
<div class="line">logger-&gt;log(kcenon::logger::log_level::error, <span class="stringliteral">&quot;Critical error occurred&quot;</span>);</div>
<div class="line"><span class="comment">// ‚ö†Ô∏è File is guaranteed to be updated before this line executes</span></div>
</div><!-- fragment --><p><b>Use Cases</b>:</p><ul>
<li>Fatal error logging before application termination</li>
<li>Security audit trails requiring immediate persistence</li>
<li>Transactional logging where data loss is unacceptable</li>
<li>Pre-crash diagnostics</li>
</ul>
<p><b>‚ö†Ô∏è Performance Warning</b>: Critical writer blocks the calling thread until write completes. Use sparingly for truly critical messages only.</p>
<h2><a class="anchor" id="autotoc_md1265"></a>
Hybrid Writer</h2>
<p><b>Features</b>:</p><ul>
<li><b>Adaptive behavior</b>: Automatically switches between async and sync based on log level</li>
<li><b>Best of both worlds</b>: Performance for info/debug, reliability for errors</li>
<li><b>Configurable threshold</b>: Set which log levels use sync vs async</li>
<li><b>Queue management</b>: Separate queue for async operations</li>
</ul>
<p><b>Usage</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/hybrid_writer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/rotating_file_writer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Configure hybrid behavior</span></div>
<div class="line">kcenon::logger::hybrid_writer_config config;</div>
<div class="line">config.sync_level = kcenon::logger::log_level::error;  <span class="comment">// Errors and above sync</span></div>
<div class="line">config.async_queue_size = 10000;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> hybrid = std::make_unique&lt;kcenon::logger::hybrid_writer&gt;(</div>
<div class="line">    std::make_unique&lt;kcenon::logger::rotating_file_writer&gt;(</div>
<div class="line">        <span class="stringliteral">&quot;hybrid.log&quot;</span>,</div>
<div class="line">        10 * 1024 * 1024,  <span class="comment">// 10MB per file</span></div>
<div class="line">        5                   <span class="comment">// Keep 5 files</span></div>
<div class="line">    ),</div>
<div class="line">    config</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> logger = kcenon::logger::logger_builder()</div>
<div class="line">    .add_writer(<span class="stringliteral">&quot;hybrid&quot;</span>, std::move(hybrid))</div>
<div class="line">    .build()</div>
<div class="line">    .value();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Debug/Info: queued (async)</span></div>
<div class="line">logger-&gt;log(kcenon::logger::log_level::debug, <span class="stringliteral">&quot;Debugging info&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Error: written immediately (sync)</span></div>
<div class="line">logger-&gt;log(kcenon::logger::log_level::error, <span class="stringliteral">&quot;Critical error!&quot;</span>);</div>
</div><!-- fragment --><p><b>Benefits</b>:</p><ul>
<li>Performance: Info/debug logs are asynchronous (low overhead)</li>
<li>Reliability: Error/fatal logs are synchronous (guaranteed persistence)</li>
<li>Simplicity: Single writer instead of multiple configurations</li>
</ul>
<p><b>Configuration Options</b>:</p><ul>
<li>Sync threshold level (default: ERROR)</li>
<li>Async queue size</li>
<li>Flush interval for async queue</li>
<li>Underlying writer configuration</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md1267"></a>
Formatting Options</h1>
<h2><a class="anchor" id="autotoc_md1268"></a>
Plain Text Formatter</h2>
<p><b>Features</b>:</p><ul>
<li>Simple, human-readable format</li>
<li>Customizable timestamp format</li>
<li>Configurable field order</li>
<li>Color support (when used with console writer)</li>
</ul>
<p><b>Format</b>: </p><div class="fragment"><div class="line">[2025-11-15 08:30:00.123] [INFO] [main.cpp:42] [main] Application started</div>
</div><!-- fragment --><p><b>Usage</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/formatters/plain_formatter.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> formatter = std::make_unique&lt;kcenon::logger::plain_formatter&gt;();</div>
<div class="line"><span class="comment">// Configure formatter...</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1269"></a>
JSON Formatter</h2>
<p><b>Features</b>:</p><ul>
<li>Machine-parseable JSON output</li>
<li>Structured field support</li>
<li>ISO 8601 timestamp format</li>
<li>Nested object support</li>
</ul>
<p><b>Format</b>: </p><div class="fragment"><div class="line">{</div>
<div class="line">  &quot;@timestamp&quot;: &quot;2025-11-15T08:30:00.123Z&quot;,</div>
<div class="line">  &quot;level&quot;: &quot;INFO&quot;,</div>
<div class="line">  &quot;message&quot;: &quot;Application started&quot;,</div>
<div class="line">  &quot;thread_id&quot;: &quot;12345&quot;,</div>
<div class="line">  &quot;file&quot;: &quot;main.cpp&quot;,</div>
<div class="line">  &quot;line&quot;: 42,</div>
<div class="line">  &quot;function&quot;: &quot;main&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Usage</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/formatters/json_formatter.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> formatter = std::make_unique&lt;kcenon::logger::json_formatter&gt;();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1270"></a>
Logfmt Formatter</h2>
<p><b>Features</b>:</p><ul>
<li>Key-value pair format</li>
<li>Easy parsing with standard tools</li>
<li>Compact representation</li>
<li>Compatible with Logstash and other log processors</li>
</ul>
<p><b>Format</b>: </p><div class="fragment"><div class="line">timestamp=&quot;2025-11-15T08:30:00.123Z&quot; level=INFO message=&quot;Application started&quot; thread_id=12345 file=main.cpp line=42 function=main</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1271"></a>
Custom Formatter</h2>
<p><b>Features</b>:</p><ul>
<li>Implement your own formatting logic</li>
<li>Full control over output format</li>
<li>Access to all log entry fields</li>
<li>Integration with custom log processors</li>
</ul>
<p><b>Usage</b>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>custom_formatter : <span class="keyword">public</span> kcenon::logger::log_formatter_interface {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::string format(<span class="keyword">const</span> kcenon::logger::log_entry&amp; entry)<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="comment">// Custom formatting logic</span></div>
<div class="line">        <span class="keywordflow">return</span> fmt::format(<span class="stringliteral">&quot;[{}] {}&quot;</span>, entry.level, entry.message);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md1273"></a>
Filtering Capabilities</h1>
<h2><a class="anchor" id="autotoc_md1274"></a>
Level-Based Filtering</h2>
<p><b>Features</b>:</p><ul>
<li>Filter by minimum log level</li>
<li>Dynamic level adjustment at runtime</li>
<li>Per-writer level configuration</li>
<li>Global and local level settings</li>
</ul>
<p><b>Usage</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/filters/level_filter.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Only log warnings and above</span></div>
<div class="line">logger-&gt;set_filter(std::make_unique&lt;kcenon::logger::level_filter&gt;(</div>
<div class="line">    kcenon::logger::log_level::warning</div>
<div class="line">));</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1275"></a>
Regex-Based Filtering</h2>
<p><b>Features</b>:</p><ul>
<li>Pattern matching on log messages</li>
<li>Include or exclude patterns</li>
<li>Multiple pattern support</li>
<li>Case-sensitive or case-insensitive matching</li>
</ul>
<p><b>Usage</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/filters/regex_filter.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Filter out sensitive information</span></div>
<div class="line">logger-&gt;set_filter(std::make_unique&lt;kcenon::logger::regex_filter&gt;(</div>
<div class="line">    <span class="stringliteral">&quot;password|secret|token&quot;</span>,</div>
<div class="line">    <span class="keyword">false</span>  <span class="comment">// Exclude matching messages</span></div>
<div class="line">));</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1276"></a>
Function-Based Filtering</h2>
<p><b>Features</b>:</p><ul>
<li>Custom filtering logic</li>
<li>Access to all log entry fields</li>
<li>Lambda or function pointer support</li>
<li>Composable filters</li>
</ul>
<p><b>Usage</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/filters/function_filter.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> custom_filter = std::make_unique&lt;kcenon::logger::function_filter&gt;(</div>
<div class="line">    [](<span class="keyword">const</span> kcenon::logger::log_entry&amp; entry) {</div>
<div class="line">        <span class="comment">// Only log messages from specific files</span></div>
<div class="line">        <span class="keywordflow">return</span> entry.file.find(<span class="stringliteral">&quot;critical_module&quot;</span>) != std::string::npos;</div>
<div class="line">    }</div>
<div class="line">);</div>
<div class="line">logger-&gt;set_filter(std::move(custom_filter));</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1277"></a>
Composite Filtering</h2>
<p><b>Features</b>:</p><ul>
<li>Combine multiple filters</li>
<li>AND/OR logic support</li>
<li>Filter chains</li>
<li>Priority-based filtering</li>
</ul>
<p><b>Usage</b>: </p><div class="fragment"><div class="line"><span class="comment">// Combine level and regex filters</span></div>
<div class="line"><span class="keyword">auto</span> composite = std::make_unique&lt;kcenon::logger::composite_filter&gt;(</div>
<div class="line">    kcenon::logger::filter_logic::AND</div>
<div class="line">);</div>
<div class="line">composite-&gt;add_filter(std::make_unique&lt;kcenon::logger::level_filter&gt;(</div>
<div class="line">    kcenon::logger::log_level::info</div>
<div class="line">));</div>
<div class="line">composite-&gt;add_filter(std::make_unique&lt;kcenon::logger::regex_filter&gt;(</div>
<div class="line">    <span class="stringliteral">&quot;critical|important&quot;</span>,</div>
<div class="line">    <span class="keyword">true</span>  <span class="comment">// Include matching messages</span></div>
<div class="line">));</div>
<div class="line">logger-&gt;set_filter(std::move(composite));</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md1279"></a>
Rotation Policies</h1>
<h2><a class="anchor" id="autotoc_md1280"></a>
Size-Based Rotation</h2>
<p><b>Features</b>:</p><ul>
<li>Rotate when file reaches configured size</li>
<li>Configurable maximum file size</li>
<li>Backup file naming with sequence numbers</li>
<li>Automatic cleanup of old backups</li>
</ul>
<p><b>Configuration</b>: </p><div class="fragment"><div class="line">kcenon::logger::rotation_config config;</div>
<div class="line">config.policy = kcenon::logger::rotation_policy::size;</div>
<div class="line">config.max_size_bytes = 10 * 1024 * 1024;  <span class="comment">// 10MB</span></div>
<div class="line">config.max_files = 5;  <span class="comment">// Keep 5 backup files</span></div>
</div><!-- fragment --><p><b>Rotation Behavior</b>:</p><ul>
<li><code>app.log</code> ‚Üí Current log file</li>
<li><code>app.log.1</code> ‚Üí Most recent backup</li>
<li><code>app.log.2</code> ‚Üí Second most recent backup</li>
<li>...</li>
<li><code>app.log.5</code> ‚Üí Oldest backup (deleted when new rotation occurs)</li>
</ul>
<h2><a class="anchor" id="autotoc_md1281"></a>
Time-Based Rotation</h2>
<p><b>Features</b>:</p><ul>
<li>Rotate at specific time intervals</li>
<li>Support for daily, hourly, weekly rotation</li>
<li>Custom rotation schedules</li>
<li>Timestamp-based backup naming</li>
</ul>
<p><b>Daily Rotation</b>: </p><div class="fragment"><div class="line">kcenon::logger::rotation_config config;</div>
<div class="line">config.policy = kcenon::logger::rotation_policy::daily;</div>
<div class="line">config.rotation_hour = 0;  <span class="comment">// Rotate at midnight</span></div>
<div class="line">config.max_files = 30;  <span class="comment">// Keep 30 days</span></div>
</div><!-- fragment --><p><b>Hourly Rotation</b>: </p><div class="fragment"><div class="line">config.policy = kcenon::logger::rotation_policy::hourly;</div>
<div class="line">config.max_files = 24;  <span class="comment">// Keep 24 hours</span></div>
</div><!-- fragment --><p><b>Rotation Behavior</b>:</p><ul>
<li><code>app.log</code> ‚Üí Current log file</li>
<li><code>app-2025-11-15.log</code> ‚Üí Previous day's log</li>
<li><code>app-2025-11-14.log</code> ‚Üí Two days ago</li>
<li>...</li>
</ul>
<h2><a class="anchor" id="autotoc_md1282"></a>
Hybrid Rotation</h2>
<p><b>Features</b>:</p><ul>
<li>Combine size and time-based policies</li>
<li>Rotate on whichever condition is met first</li>
<li>Flexible configuration</li>
<li>Optimal for variable-load applications</li>
</ul>
<p><b>Configuration</b>: </p><div class="fragment"><div class="line">kcenon::logger::rotation_config config;</div>
<div class="line">config.policy = kcenon::logger::rotation_policy::hybrid;</div>
<div class="line">config.max_size_bytes = 100 * 1024 * 1024;  <span class="comment">// 100MB OR</span></div>
<div class="line">config.rotation_interval = std::chrono::hours(24);  <span class="comment">// 24 hours</span></div>
<div class="line">config.max_files = 10;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1283"></a>
Compression Support</h2>
<p><b>Features</b>:</p><ul>
<li>Automatic compression of rotated files</li>
<li>Support for gzip, bzip2</li>
<li>Configurable compression level</li>
<li>Background compression (non-blocking)</li>
</ul>
<p><b>Configuration</b>: </p><div class="fragment"><div class="line">kcenon::logger::rotation_config config;</div>
<div class="line">config.compression = kcenon::logger::compression_type::gzip;</div>
<div class="line">config.compression_level = 6;  <span class="comment">// 1-9, higher = better compression</span></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md1285"></a>
Security Features</h1>
<h2><a class="anchor" id="autotoc_md1286"></a>
Secure Key Storage</h2>
<p><b>Features</b>:</p><ul>
<li>RAII-based encryption key management</li>
<li>Automatic memory cleanup using OpenSSL <code>OPENSSL_cleanse()</code></li>
<li>File permission enforcement (0600 - owner read/write only)</li>
<li>Cryptographically secure random key generation</li>
<li><b>OpenSSL 3.x compatible</b> with EVP_MAC API for HMAC operations</li>
<li>Backward compatible with OpenSSL 1.1.x (deprecated, EOL September 2023)</li>
</ul>
<p><b>Usage</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/security/secure_key_storage.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> key_storage = kcenon::logger::secure_key_storage::create();</div>
<div class="line"><span class="comment">// Key is automatically cleaned from memory when object is destroyed</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1287"></a>
Path Validation</h2>
<p><b>Features</b>:</p><ul>
<li>Path traversal attack prevention</li>
<li>Symbolic link validation</li>
<li>Base directory enforcement</li>
<li>Filename character restrictions</li>
</ul>
<p><b>Protections</b>:</p><ul>
<li>Blocks <code>../</code> path traversal attempts</li>
<li>Validates symlinks don't escape base directory</li>
<li>Restricts dangerous characters in filenames</li>
<li>Enforces whitelisted file extensions</li>
</ul>
<p><b>Usage</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/security/path_validator.h&gt;</span></div>
<div class="line"> </div>
<div class="line">kcenon::logger::path_validator validator(<span class="stringliteral">&quot;/var/log/app&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> result = validator.validate(<span class="stringliteral">&quot;/var/log/app/user-input.log&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (!result) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Invalid path: &quot;</span> &lt;&lt; result.error().message() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1288"></a>
Signal Handler Safety</h2>
<p><b>Features</b>:</p><ul>
<li>Centralized signal handler management</li>
<li>Thread-safe logger registration</li>
<li>Emergency flush for crash scenarios</li>
<li>POSIX async-signal-safe functions only</li>
</ul>
<p><b>Protected Signals</b>:</p><ul>
<li><code>SIGSEGV</code>: Segmentation fault</li>
<li><code>SIGABRT</code>: Abort signal</li>
<li><code>SIGFPE</code>: Floating point exception</li>
<li><code>SIGILL</code>: Illegal instruction</li>
<li><code>SIGTERM</code>: Termination request</li>
<li><code>SIGINT</code>: Interrupt (Ctrl+C)</li>
</ul>
<p><b>Usage</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/safety/crash_safe_logger.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Install signal handlers for crash detection</span></div>
<div class="line">kcenon::logger::crash_safe_logger::install_signal_handlers();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1289"></a>
Security Audit Logging</h2>
<p><b>Features</b>:</p><ul>
<li>Tamper-evident audit trail</li>
<li>JSON-formatted audit entries</li>
<li>HMAC-SHA256 signatures for integrity verification</li>
<li>Tracks lifecycle, encryption, and security events</li>
</ul>
<p><b>Audit Entry Format</b>: </p><div class="fragment"><div class="line">{</div>
<div class="line">  &quot;@timestamp&quot;: &quot;2025-11-15T08:30:00.123Z&quot;,</div>
<div class="line">  &quot;event_type&quot;: &quot;logger_start&quot;,</div>
<div class="line">  &quot;user&quot;: &quot;application&quot;,</div>
<div class="line">  &quot;action&quot;: &quot;Logger initialized&quot;,</div>
<div class="line">  &quot;hmac&quot;: &quot;a3d5c8e2f1b4...&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1290"></a>
Sensitive Data Sanitization</h2>
<p><b>Features</b>:</p><ul>
<li>Automatic detection and masking of sensitive data</li>
<li>Configurable sanitization rules</li>
<li>Support for emails, credit cards, tokens, passwords</li>
<li>Custom pattern support</li>
</ul>
<p><b>Usage</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/security/log_sanitizer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create sanitizer with default rules</span></div>
<div class="line"><span class="keyword">auto</span> sanitizer = std::make_shared&lt;kcenon::logger::log_sanitizer&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sanitize logs before writing</span></div>
<div class="line">std::string message = <span class="stringliteral">&quot;User login: john.doe@example.com, Card: 4532-1234-5678-9012&quot;</span>;</div>
<div class="line">std::string sanitized = sanitizer-&gt;sanitize(message);</div>
<div class="line"><span class="comment">// Result: &quot;User login: j******e@example.com, Card: 4532********9012&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add custom sanitization rules</span></div>
<div class="line">sanitizer-&gt;add_rule({</div>
<div class="line">    <span class="stringliteral">&quot;jwt_token&quot;</span>,</div>
<div class="line">    std::regex(<span class="stringliteral">&quot;Bearer\\s+[A-Za-z0-9\\-_]+\\.[A-Za-z0-9\\-_]+\\.[A-Za-z0-9\\-_]+&quot;</span>),</div>
<div class="line">    [](<span class="keyword">const</span> std::smatch&amp; match) { <span class="keywordflow">return</span> <span class="stringliteral">&quot;Bearer [REDACTED]&quot;</span>; }</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1291"></a>
Access Control</h2>
<p><b>Features</b>:</p><ul>
<li>Role-based access control for logging</li>
<li>File-specific permissions</li>
<li>User context tracking</li>
<li>Permission level enforcement</li>
</ul>
<p><b>Usage</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/security/access_control_filter.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create access control filter</span></div>
<div class="line"><span class="keyword">auto</span> access_filter = std::make_unique&lt;kcenon::logger::access_control_filter&gt;(</div>
<div class="line">    kcenon::logger::permission_level::write_info</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set file-specific permissions</span></div>
<div class="line">access_filter-&gt;set_file_permission(<span class="stringliteral">&quot;.*secure.*&quot;</span>,</div>
<div class="line">    kcenon::logger::permission_level::admin);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set user context</span></div>
<div class="line">access_filter-&gt;set_user_context(<span class="stringliteral">&quot;current_user&quot;</span>,</div>
<div class="line">    kcenon::logger::permission_level::write_info);</div>
<div class="line"> </div>
<div class="line">logger-&gt;set_filter(std::move(access_filter));</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1292"></a>
Compliance Support</h2>
<p><b>Standards</b>:</p><ul>
<li><b>GDPR</b>: Data minimization, right to erasure, audit trails</li>
<li><b>PCI DSS</b>: Secure logging of payment data, access controls</li>
<li><b>ISO 27001</b>: Information security management</li>
<li><b>SOC 2</b>: Security, availability, processing integrity</li>
</ul>
<p><b>OWASP Top 10 Mitigations</b>:</p><ul>
<li><b>A01 (Broken Access Control)</b>: Role-based access control</li>
<li><b>A02 (Cryptographic Failures)</b>: Secure key storage, encryption support</li>
<li><b>A03 (Injection)</b>: Input validation, sanitization</li>
<li><b>A09 (Security Logging Failures)</b>: Comprehensive audit logging</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md1294"></a>
Advanced Capabilities</h1>
<h2><a class="anchor" id="autotoc_md1295"></a>
Structured Logging</h2>
<p><b>Features</b>:</p><ul>
<li>Key-value pair logging</li>
<li>Nested object support</li>
<li>Type-safe field addition</li>
<li>Multiple output formats (JSON, logfmt)</li>
</ul>
<p><b>Usage</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/structured/structured_logger.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create structured logger wrapper</span></div>
<div class="line"><span class="keyword">auto</span> structured = std::make_shared&lt;kcenon::logger::structured_logger&gt;(</div>
<div class="line">    logger,</div>
<div class="line">    kcenon::logger::structured_logger::output_format::json</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Log with structured fields</span></div>
<div class="line">structured-&gt;info(<span class="stringliteral">&quot;User logged in&quot;</span>)</div>
<div class="line">    .field(<span class="stringliteral">&quot;user_id&quot;</span>, 12345)</div>
<div class="line">    .field(<span class="stringliteral">&quot;ip_address&quot;</span>, <span class="stringliteral">&quot;192.168.1.1&quot;</span>)</div>
<div class="line">    .field(<span class="stringliteral">&quot;session_duration&quot;</span>, 3600)</div>
<div class="line">    .commit();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Output (JSON format):</span></div>
<div class="line"><span class="comment">// {&quot;@timestamp&quot;:&quot;2025-11-15T08:30:00Z&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;message&quot;:&quot;User logged in&quot;,</span></div>
<div class="line"><span class="comment">//  &quot;thread_id&quot;:&quot;12345&quot;,&quot;user_id&quot;:12345,&quot;ip_address&quot;:&quot;192.168.1.1&quot;,&quot;session_duration&quot;:3600}</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1296"></a>
Log Routing</h2>
<p><b>Features</b>:</p><ul>
<li>Conditional routing based on log level, message content</li>
<li>Multiple target support</li>
<li>Route to specific writers</li>
<li>Stop propagation option</li>
<li>Exclusive routing mode (messages only go to matched routes)</li>
<li>Direct logger integration via <code>logger_builder</code></li>
</ul>
<p><b>Builder API (Recommended)</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/core/logger_builder.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/file_writer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Configure routing during logger construction</span></div>
<div class="line"><span class="keyword">auto</span> logger = kcenon::logger::logger_builder()</div>
<div class="line">    .add_writer(<span class="stringliteral">&quot;all&quot;</span>, std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>))</div>
<div class="line">    .add_writer(<span class="stringliteral">&quot;errors&quot;</span>, std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;errors.log&quot;</span>))</div>
<div class="line">    .add_writer(<span class="stringliteral">&quot;security&quot;</span>, std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;security.log&quot;</span>))</div>
<div class="line">    <span class="comment">// Route errors to dedicated file</span></div>
<div class="line">    .route_level(kcenon::logger::log_level::error, {<span class="stringliteral">&quot;errors&quot;</span>})</div>
<div class="line">    <span class="comment">// Route security-related messages by pattern</span></div>
<div class="line">    .route_pattern(<span class="stringliteral">&quot;[Ss]ecurity|[Aa]uth&quot;</span>, {<span class="stringliteral">&quot;security&quot;</span>})</div>
<div class="line">    <span class="comment">// Enable exclusive routing (non-matching messages are dropped)</span></div>
<div class="line">    .with_exclusive_routing(<span class="keyword">true</span>)</div>
<div class="line">    .build()</div>
<div class="line">    .value();</div>
</div><!-- fragment --><p><b>Direct Router Access</b>: </p><div class="fragment"><div class="line"><span class="comment">// Access router after logger creation</span></div>
<div class="line"><span class="keyword">auto</span>&amp; router = logger-&gt;get_router();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Configure routing dynamically</span></div>
<div class="line">router.set_exclusive_routes(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add custom route with filter</span></div>
<div class="line">kcenon::logger::routing::route_config config;</div>
<div class="line">config.writer_names = {<span class="stringliteral">&quot;errors&quot;</span>};</div>
<div class="line">config.filter = std::make_unique&lt;kcenon::logger::filters::exact_level_filter&gt;(</div>
<div class="line">    kcenon::logger::log_level::error</div>
<div class="line">);</div>
<div class="line">config.stop_propagation = <span class="keyword">false</span>;</div>
<div class="line">router.add_route(std::move(config));</div>
</div><!-- fragment --><p><b>Available Filters</b>:</p><ul>
<li><code>level_filter</code>: Passes messages at or above minimum level</li>
<li><code>exact_level_filter</code>: Passes only messages at exactly the specified level</li>
<li><code>regex_filter</code>: Pattern matching on message content</li>
<li><code>function_filter</code>: Custom predicate-based filtering</li>
<li><code>composite_filter</code>: Combine multiple filters with AND/OR logic</li>
</ul>
<p><b>Routing Modes</b>:</p><ul>
<li><b>Non-exclusive (default)</b>: All messages go to all writers</li>
<li><b>Exclusive</b>: Only messages matching a route go to matched writers; unmatched messages are dropped</li>
</ul>
<h2><a class="anchor" id="autotoc_md1297"></a>
Performance Metrics Collection</h2>
<p><b>Features</b>:</p><ul>
<li>Built-in metrics collection</li>
<li>Real-time performance monitoring</li>
<li>Queue utilization tracking</li>
<li>Message throughput calculation</li>
</ul>
<p><b>Usage</b>: </p><div class="fragment"><div class="line"><span class="comment">// Enable metrics collection</span></div>
<div class="line">logger-&gt;enable_metrics_collection(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Log some messages</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000; ++i) {</div>
<div class="line">    logger-&gt;log(kcenon::logger::log_level::info, <span class="stringliteral">&quot;Test message&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get current metrics</span></div>
<div class="line"><span class="keyword">auto</span> metrics = logger-&gt;get_current_metrics();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Messages per second: &quot;</span> &lt;&lt; metrics.get_messages_per_second() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Average enqueue time: &quot;</span> &lt;&lt; metrics.get_avg_enqueue_time_ns() &lt;&lt; <span class="stringliteral">&quot; ns\n&quot;</span>;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Queue utilization: &quot;</span> &lt;&lt; metrics.get_queue_utilization_percent() &lt;&lt; <span class="stringliteral">&quot;%\n&quot;</span>;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1298"></a>
Real-time Log Analysis</h2>
<p><b>Features</b>:</p><ul>
<li>Pattern matching and detection</li>
<li>Statistical analysis</li>
<li>Alert rules</li>
<li>Report generation</li>
</ul>
<p><b>Usage</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/analysis/log_analyzer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create analyzer with 60-second windows</span></div>
<div class="line"><span class="keyword">auto</span> analyzer = std::make_unique&lt;kcenon::logger::log_analyzer&gt;(</div>
<div class="line">    std::chrono::seconds(60),</div>
<div class="line">    60  <span class="comment">// Keep 1 hour of history</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Track patterns</span></div>
<div class="line">analyzer-&gt;add_pattern(<span class="stringliteral">&quot;errors&quot;</span>, <span class="stringliteral">&quot;error|fail|exception&quot;</span>);</div>
<div class="line">analyzer-&gt;add_pattern(<span class="stringliteral">&quot;slow_queries&quot;</span>, <span class="stringliteral">&quot;query took \\d{4,} ms&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add alert rules</span></div>
<div class="line">analyzer-&gt;add_alert_rule({</div>
<div class="line">    <span class="stringliteral">&quot;high_error_rate&quot;</span>,</div>
<div class="line">    [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; stats) {</div>
<div class="line">        <span class="keyword">auto</span> errors = stats.level_counts.count(kcenon::logger::log_level::error) ?</div>
<div class="line">                     stats.level_counts.at(kcenon::logger::log_level::error) : 0;</div>
<div class="line">        <span class="keywordflow">return</span> errors &gt; 100;  <span class="comment">// Alert if &gt;100 errors per minute</span></div>
<div class="line">    },</div>
<div class="line">    [](<span class="keyword">const</span> std::string&amp; rule, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; stats) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ALERT: High error rate detected!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Generate report</span></div>
<div class="line">std::string report = analyzer-&gt;generate_report(std::chrono::minutes(10));</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1299"></a>
Distributed Logging</h2>
<p><b>Features</b>:</p><ul>
<li>Network-based log transmission</li>
<li>Log server for centralized collection</li>
<li>Multiple protocol support (TCP, UDP)</li>
<li>Compression and encryption support</li>
</ul>
<p><b>Client (Send Logs)</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/network_writer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send logs to remote server</span></div>
<div class="line">logger-&gt;add_writer(<span class="stringliteral">&quot;remote&quot;</span>, std::make_unique&lt;kcenon::logger::network_writer&gt;(</div>
<div class="line">    <span class="stringliteral">&quot;log-server.example.com&quot;</span>,</div>
<div class="line">    9999,</div>
<div class="line">    kcenon::logger::network_writer::protocol_type::tcp</div>
<div class="line">));</div>
</div><!-- fragment --><p><b>Server (Receive Logs)</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/server/log_server.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create log server to receive logs</span></div>
<div class="line"><span class="keyword">auto</span> server = std::make_unique&lt;kcenon::logger::log_server&gt;(9999, <span class="keyword">true</span>);</div>
<div class="line">server-&gt;add_handler([](<span class="keyword">const</span> kcenon::logger::log_server::network_log_entry&amp; entry) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Received log from &quot;</span> &lt;&lt; entry.source_address</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; entry.raw_data &lt;&lt; std::endl;</div>
<div class="line">});</div>
<div class="line">server-&gt;start();</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md1301"></a>
See Also</h1>
<ul>
<li><a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2BENCHMARKS.html">Performance Benchmarks</a> - Detailed performance analysis</li>
<li>Architecture Overview - System architecture and design</li>
<li>API Reference - Complete API documentation</li>
<li>Security Guide - Security best practices</li>
<li><a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2guides_2GETTING__STARTED.html">Getting Started</a> - Quick start guide </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Feb 8 2026 04:33:14 for Logger System by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
