<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Logger System: 비동기 Writer 구현체 가이드</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Logger System<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-performance C++20 thread-safe logging system with asynchronous capabilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__2home_2runner_2work_2logger__system_2logger__system_2docs_2advanced_2ASYNC__WRITERS__KO.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">비동기 Writer 구현체 가이드</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md185"></a> </p><blockquote class="doxtable">
<p>&zwj;<b>Language:</b> <a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2advanced_2ASYNC__WRITERS.html">English</a> | <b>한국어</b> </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md186"></a>
개요</h1>
<p>Logger System은 다양한 사용 사례에 최적화된 여러 비동기 writer 구현체를 제공합니다. 이 가이드는 각 구현체의 차이점을 이해하고 적절한 구현체를 선택하는 데 도움을 줍니다.</p>
<p><b>버전:</b> 1.0.0 <b>최종 업데이트:</b> 2025-12-31</p>
<hr  />
<h1><a class="anchor" id="autotoc_md188"></a>
목차</h1>
<ul>
<li>빠른 선택 가이드</li>
<li>구현체 비교</li>
<li>상세 설명<ul>
<li>async_writer</li>
<li>async_worker</li>
<li>high_performance_async_writer</li>
</ul>
</li>
<li>성능 특성</li>
<li>사용 예제</li>
<li>모범 사례</li>
<li>마이그레이션 가이드</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md190"></a>
빠른 선택 가이드</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">사용 사례   </th><th class="markdownTableHeadNone">권장 구현체    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>일반적인 비동기 로깅</b>   </td><td class="markdownTableBodyNone"><code>async_writer</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>간단한 비동기 래퍼</b>   </td><td class="markdownTableBodyNone"><code>async_writer</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>최대 처리량 (&gt;1M msg/sec)</b>   </td><td class="markdownTableBodyNone"><code>high_performance_async_writer</code> (내부)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>커스텀 비동기 태스크 처리</b>   </td><td class="markdownTableBodyNone"><code>async_worker</code> (내부)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>프로덕션 애플리케이션</b>   </td><td class="markdownTableBodyNone"><code>async_writer</code> (적절한 큐 크기 설정)   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md191"></a>
선택 플로우차트</h2>
<div class="fragment"><div class="line">시작</div>
<div class="line">  │</div>
<div class="line">  ├─ 간단한 비동기 래퍼 필요? ─────────────► async_writer (공개 API)</div>
<div class="line">  │</div>
<div class="line">  ├─ 최대 처리량 필요?</div>
<div class="line">  │   │</div>
<div class="line">  │   └─ 예 ───────────────────────────────► high_performance_async_writer</div>
<div class="line">  │                                           (내부, 커스텀 빌드 필요)</div>
<div class="line">  │</div>
<div class="line">  └─ 내부 컴포넌트 구축? ──────────────────► async_worker (내부 API)</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md193"></a>
구현체 비교</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">측면   </th><th class="markdownTableHeadNone"><code>async_writer</code>   </th><th class="markdownTableHeadNone"><code>async_worker</code>   </th><th class="markdownTableHeadNone"><code>high_performance_async_writer</code>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>위치</b>   </td><td class="markdownTableBodyNone">공개 API   </td><td class="markdownTableBodyNone">내부   </td><td class="markdownTableBodyNone">내부    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>헤더</b>   </td><td class="markdownTableBodyNone"><code>writers/async_writer.h</code>   </td><td class="markdownTableBodyNone"><code>src/impl/async/</code>   </td><td class="markdownTableBodyNone"><code>src/impl/async/</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>목적</b>   </td><td class="markdownTableBodyNone">모든 writer 래핑   </td><td class="markdownTableBodyNone">범용 태스크 워커   </td><td class="markdownTableBodyNone">최대 처리량    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>큐 타입</b>   </td><td class="markdownTableBodyNone"><code>std::queue</code> + mutex   </td><td class="markdownTableBodyNone"><code>std::queue</code> + mutex   </td><td class="markdownTableBodyNone">Lock-free 큐    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>메모리 풀링</b>   </td><td class="markdownTableBodyNone">없음   </td><td class="markdownTableBodyNone">없음   </td><td class="markdownTableBodyNone">있음 (설정 가능)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>배치 처리</b>   </td><td class="markdownTableBodyNone">없음   </td><td class="markdownTableBodyNone">없음   </td><td class="markdownTableBodyNone">있음 (동적 크기)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>jthread 지원</b>   </td><td class="markdownTableBodyNone">없음   </td><td class="markdownTableBodyNone">있음 (fallback 포함)   </td><td class="markdownTableBodyNone">없음    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>성능 통계</b>   </td><td class="markdownTableBodyNone">없음   </td><td class="markdownTableBodyNone">드롭 카운트만   </td><td class="markdownTableBodyNone">전체 통계    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>권장 대상</b>   </td><td class="markdownTableBodyNone">대부분의 사용 사례   </td><td class="markdownTableBodyNone">내부 컴포넌트   </td><td class="markdownTableBodyNone">대용량 로깅   </td></tr>
</table>
<hr  />
<h1><a class="anchor" id="autotoc_md195"></a>
상세 설명</h1>
<h2><a class="anchor" id="autotoc_md196"></a>
1. async_writer (공개 API)</h2>
<p><b>위치:</b> <code>include/kcenon/logger/writers/async_writer.h</code></p>
<p><code>async_writer</code>는 **대부분의 애플리케이션에 권장되는 선택**입니다. 모든 <code>base_writer</code> 구현체를 래핑하여 백그라운드 스레드를 통한 비동기 쓰기 기능을 제공합니다.</p>
<h3><a class="anchor" id="autotoc_md197"></a>
주요 특징</h3>
<ul>
<li><b>범용 래퍼</b>: 모든 <code>base_writer</code>와 호환 (콘솔, 파일, 네트워크 등)</li>
<li><b>설정 가능한 큐 크기</b>: 기본값 10,000 메시지</li>
<li><b>설정 가능한 플러시 타임아웃</b>: 기본값 5초</li>
<li><b>정상 종료</b>: 중지 시 남은 메시지 처리</li>
<li><b>스레드 안전</b>: 여러 스레드에서 동시 쓰기 가능</li>
</ul>
<h3><a class="anchor" id="autotoc_md198"></a>
아키텍처</h3>
<div class="fragment"><div class="line">┌─────────────┐     ┌──────────────┐     ┌────────────────┐</div>
<div class="line">│ 애플리케이션 │────►│ async_writer │────►│ wrapped_writer │</div>
<div class="line">│   스레드    │     │   (큐)       │     │  (모든 writer) │</div>
<div class="line">└─────────────┘     └──────┬───────┘     └────────────────┘</div>
<div class="line">                           │</div>
<div class="line">                    ┌──────┴───────┐</div>
<div class="line">                    │ 워커 스레드   │</div>
<div class="line">                    └──────────────┘</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md199"></a>
API 레퍼런스</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>async_writer : <span class="keyword">public</span> base_writer {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// 생성자</span></div>
<div class="line">    <span class="keyword">explicit</span> async_writer(</div>
<div class="line">        std::unique_ptr&lt;base_writer&gt; wrapped_writer,</div>
<div class="line">        std::size_t queue_size = 10000,</div>
<div class="line">        std::chrono::seconds flush_timeout = std::chrono::seconds(5));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 제어 메서드</span></div>
<div class="line">    <span class="keywordtype">void</span> start();                        <span class="comment">// 워커 스레드 시작</span></div>
<div class="line">    <span class="keywordtype">void</span> stop(<span class="keywordtype">bool</span> force_flush = <span class="keyword">true</span>);  <span class="comment">// 선택적 플러시와 함께 중지</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// base_writer 인터페이스</span></div>
<div class="line">    common::VoidResult write(...) <span class="keyword">override</span>;</div>
<div class="line">    common::VoidResult flush() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> is_healthy() <span class="keyword">const override</span>;</div>
<div class="line">    std::string get_name() <span class="keyword">const override</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md200"></a>
사용 시기</h3>
<ul>
<li>표준 비동기 로깅 요구사항</li>
<li>느린 writer 래핑 (파일, 네트워크)</li>
<li>중간 규모 로깅 볼륨의 애플리케이션 (&lt;100K msg/sec)</li>
<li>최대 성능보다 단순성이 중요할 때</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md202"></a>
2. async_worker (내부)</h2>
<p><b>위치:</b> <code>src/impl/async/async_worker.h</code></p>
<p><code>async_worker</code>는 태스크 기반 비동기 처리를 위한 **저수준 컴포넌트**입니다. 내부 사용을 위해 설계되었으며 비동기 컴포넌트 구축의 기반을 제공합니다.</p>
<h3><a class="anchor" id="autotoc_md203"></a>
주요 특징</h3>
<ul>
<li><b>태스크 기반 처리</b>: 유연성을 위해 <code>std::function&lt;void()&gt;</code> 사용</li>
<li><b>jthread 호환성</b>: 가능한 경우 <code>std::jthread</code> 사용, fallback 포함</li>
<li><b>협력적 취소</b>: stop 토큰을 통한 정상 종료</li>
<li><b>드롭된 태스크 추적</b>: 큐 오버플로우 모니터링</li>
</ul>
<h3><a class="anchor" id="autotoc_md204"></a>
아키텍처</h3>
<div class="fragment"><div class="line">┌──────────────┐     ┌──────────────┐</div>
<div class="line">│ 태스크 소스   │────►│ async_worker │────► 태스크 순차 실행</div>
<div class="line">│   (내부)     │     │   (큐)       │</div>
<div class="line">└──────────────┘     └──────────────┘</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md205"></a>
사용 시기</h3>
<ul>
<li>내부 비동기 컴포넌트 구축</li>
<li>커스텀 태스크 처리 요구사항</li>
<li>다른 비동기 시스템과의 통합</li>
</ul>
<blockquote class="doxtable">
<p>&zwj;<b>참고:</b> 이것은 내부 API이며 공지 없이 변경될 수 있습니다. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md206"></a>
&lt;/blockquote&gt;</h1>
<h2><a class="anchor" id="autotoc_md207"></a>
3. high_performance_async_writer (내부)</h2>
<p><b>위치:</b> <code>src/impl/async/high_performance_async_writer.h</code></p>
<p><code>high_performance_async_writer</code>는 <b>최대 처리량</b> 시나리오에 최적화되어 있습니다. Lock-free 큐, 메모리 풀링, 배치 처리를 결합하여 대용량 로깅을 지원합니다.</p>
<h3><a class="anchor" id="autotoc_md208"></a>
주요 특징</h3>
<ul>
<li><b>Lock-free 큐</b>: 높은 동시성 시나리오에서 경합 최소화</li>
<li><b>메모리 풀링</b>: 할당 오버헤드 감소</li>
<li><b>동적 배치 처리</b>: 부하에 따라 배치 크기 조정</li>
<li><b>백프레셔 처리</b>: 큐 가득 참 동작 설정 가능</li>
<li><b>성능 통계</b>: 상세 메트릭 (지연 시간, 처리량, 성공률)</li>
</ul>
<h3><a class="anchor" id="autotoc_md209"></a>
아키텍처</h3>
<div class="fragment"><div class="line">┌─────────────┐     ┌─────────────────────────────────────┐</div>
<div class="line">│ 애플리케이션 │     │  high_performance_async_writer      │</div>
<div class="line">│   스레드    │────►│  ┌─────────────┐  ┌──────────────┐ │</div>
<div class="line">└─────────────┘     │  │ Lock-free   │  │ Batch        │ │</div>
<div class="line">                    │  │ Queue       │─►│ Processor    │─┼──► Writer</div>
<div class="line">                    │  └─────────────┘  └──────────────┘ │</div>
<div class="line">                    │  ┌─────────────┐                   │</div>
<div class="line">                    │  │ Memory Pool │                   │</div>
<div class="line">                    │  └─────────────┘                   │</div>
<div class="line">                    └─────────────────────────────────────┘</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md210"></a>
설정</h3>
<div class="fragment"><div class="line"><span class="keyword">struct </span>config {</div>
<div class="line">    <span class="comment">// 큐 설정</span></div>
<div class="line">    <span class="keywordtype">size_t</span> queue_size{8192};              <span class="comment">// 2의 거듭제곱이어야 함</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 배치 처리</span></div>
<div class="line">    batch_processor::config batch_config;</div>
<div class="line">    <span class="comment">// - initial_batch_size: 50</span></div>
<div class="line">    <span class="comment">// - max_batch_size: 500</span></div>
<div class="line">    <span class="comment">// - min_batch_size: 10</span></div>
<div class="line">    <span class="comment">// - max_wait_time: 100ms</span></div>
<div class="line">    <span class="comment">// - enable_dynamic_sizing: true</span></div>
<div class="line">    <span class="comment">// - enable_back_pressure: true</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 메모리 풀</span></div>
<div class="line">    memory::object_pool&lt;...&gt;::config pool_config;</div>
<div class="line">    <span class="comment">// - initial_size: 200</span></div>
<div class="line">    <span class="comment">// - max_size: 2000</span></div>
<div class="line">    <span class="comment">// - allow_growth: true</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 기능</span></div>
<div class="line">    <span class="keywordtype">bool</span> enable_memory_pooling{<span class="keyword">true</span>};</div>
<div class="line">    <span class="keywordtype">bool</span> enable_batch_processing{<span class="keyword">true</span>};</div>
<div class="line">    std::chrono::microseconds flush_timeout{1000};</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md211"></a>
사용 시기</h3>
<ul>
<li>초당 100K 이상의 메시지 로깅</li>
<li>지연 시간에 민감한 애플리케이션</li>
<li>높은 스레드 경합이 있는 시스템</li>
<li>상세한 성능 메트릭이 필요할 때</li>
</ul>
<blockquote class="doxtable">
<p>&zwj;<b>참고:</b> 현재 내부 API입니다. 프로덕션 사용 가이드는 메인테이너에게 문의하세요. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md212"></a>
&lt;/blockquote&gt;</h1>
<h1><a class="anchor" id="autotoc_md213"></a>
성능 특성</h1>
<h2><a class="anchor" id="autotoc_md214"></a>
벤치마크 비교</h2>
<p><b>테스트 환경:</b> Apple M1 (8코어), 16GB RAM, macOS</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">메트릭   </th><th class="markdownTableHeadNone">async_writer   </th><th class="markdownTableHeadNone">high_performance_async_writer    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>단일 스레드 처리량</b>   </td><td class="markdownTableBodyNone">~500K msg/s   </td><td class="markdownTableBodyNone">~2M msg/s    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>8스레드 처리량</b>   </td><td class="markdownTableBodyNone">~200K msg/s   </td><td class="markdownTableBodyNone">~800K msg/s    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>평균 enqueue 지연</b>   </td><td class="markdownTableBodyNone">~500 ns   </td><td class="markdownTableBodyNone">~150 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>메모리 오버헤드</b>   </td><td class="markdownTableBodyNone">낮음   </td><td class="markdownTableBodyNone">중간 (풀)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>큐 가득 참 동작</b>   </td><td class="markdownTableBodyNone">에러 반환   </td><td class="markdownTableBodyNone">백프레셔   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md215"></a>
지연 시간 분포</h2>
<div class="fragment"><div class="line">async_writer:</div>
<div class="line">  P50: 400 ns</div>
<div class="line">  P99: 2 μs</div>
<div class="line">  P99.9: 10 μs</div>
<div class="line"> </div>
<div class="line">high_performance_async_writer:</div>
<div class="line">  P50: 100 ns</div>
<div class="line">  P99: 500 ns</div>
<div class="line">  P99.9: 2 μs</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md217"></a>
사용 예제</h1>
<h2><a class="anchor" id="autotoc_md218"></a>
예제 1: 기본 async_writer 사용</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/async_writer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/file_writer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 비동기 파일 writer 생성</span></div>
<div class="line"><span class="keyword">auto</span> file_writer = std::make_unique&lt;kcenon::logger::file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> async = std::make_unique&lt;kcenon::logger::async_writer&gt;(</div>
<div class="line">    std::move(file_writer),</div>
<div class="line">    10000,  <span class="comment">// 큐 크기</span></div>
<div class="line">    std::chrono::seconds(5)  <span class="comment">// 플러시 타임아웃</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 비동기 writer 시작</span></div>
<div class="line">async-&gt;start();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// writer 사용</span></div>
<div class="line">async-&gt;write(log_level::info, <span class="stringliteral">&quot;Hello async!&quot;</span>, __FILE__, __LINE__, __func__,</div>
<div class="line">             std::chrono::system_clock::now());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 플러시 및 중지</span></div>
<div class="line">async-&gt;flush();</div>
<div class="line">async-&gt;stop();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md219"></a>
예제 2: 콘솔 출력과 async_writer</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/async_writer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/console_writer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 콘솔 writer를 비동기로 래핑</span></div>
<div class="line"><span class="keyword">auto</span> console = std::make_unique&lt;kcenon::logger::console_writer&gt;();</div>
<div class="line"><span class="keyword">auto</span> async_console = std::make_unique&lt;kcenon::logger::async_writer&gt;(</div>
<div class="line">    std::move(console),</div>
<div class="line">    5000  <span class="comment">// 콘솔용 작은 큐</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">async_console-&gt;start();</div>
<div class="line"><span class="comment">// ... async_console 사용 ...</span></div>
<div class="line">async_console-&gt;stop(<span class="keyword">true</span>);  <span class="comment">// 남은 메시지 플러시</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md220"></a>
예제 3: 큐 가득 참 처리</h2>
<div class="fragment"><div class="line"><span class="keyword">auto</span> async = std::make_unique&lt;kcenon::logger::async_writer&gt;(</div>
<div class="line">    std::make_unique&lt;kcenon::logger::file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>),</div>
<div class="line">    1000  <span class="comment">// 데모용 작은 큐</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">async-&gt;start();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 에러 처리와 함께 쓰기</span></div>
<div class="line"><span class="keyword">auto</span> result = async-&gt;write(log_level::info, <span class="stringliteral">&quot;Message&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, 0, <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">                           std::chrono::system_clock::now());</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!result.is_ok()) {</div>
<div class="line">    <span class="keywordflow">if</span> (result.error().code() == logger_error_code::queue_full) {</div>
<div class="line">        <span class="comment">// 큐 가득 참 처리 - 동기로 쓰거나 드롭</span></div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;비동기 큐 가득 참, 메시지 드롭됨\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md221"></a>
예제 4: 정상 종료 패턴</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>application {</div>
<div class="line">    std::unique_ptr&lt;async_writer&gt; logger_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    application() {</div>
<div class="line">        <span class="keyword">auto</span> writer = std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>);</div>
<div class="line">        logger_ = std::make_unique&lt;async_writer&gt;(std::move(writer));</div>
<div class="line">        logger_-&gt;start();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ~application() {</div>
<div class="line">        <span class="comment">// 종료 시 모든 로그 플러시 보장</span></div>
<div class="line">        <span class="keywordflow">if</span> (logger_) {</div>
<div class="line">            logger_-&gt;flush();  <span class="comment">// 큐가 비워질 때까지 대기</span></div>
<div class="line">            logger_-&gt;stop(<span class="keyword">true</span>);  <span class="comment">// 플러시와 함께 중지</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> log(<span class="keyword">const</span> std::string&amp; message) {</div>
<div class="line">        logger_-&gt;write(log_level::info, message, <span class="stringliteral">&quot;&quot;</span>, 0, <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">                       std::chrono::system_clock::now());</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md223"></a>
모범 사례</h1>
<h2><a class="anchor" id="autotoc_md224"></a>
1. 큐 크기 선택</h2>
<div class="fragment"><div class="line"><span class="comment">// 저용량 (&lt;1K msg/sec): 작은 큐</span></div>
<div class="line">async_writer(writer, 1000);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 중간 용량 (1K-10K msg/sec): 기본값</span></div>
<div class="line">async_writer(writer, 10000);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 고용량 (&gt;10K msg/sec): 큰 큐</span></div>
<div class="line">async_writer(writer, 100000);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md225"></a>
2. 플러시 타임아웃 설정</h2>
<div class="fragment"><div class="line"><span class="comment">// 빠른 플러시 필요 (인터랙티브 앱)</span></div>
<div class="line">async_writer(writer, 10000, std::chrono::seconds(1));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 표준 애플리케이션</span></div>
<div class="line">async_writer(writer, 10000, std::chrono::seconds(5));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 배치 지향 (백그라운드 서비스)</span></div>
<div class="line">async_writer(writer, 10000, std::chrono::seconds(30));</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md226"></a>
3. 에러 처리</h2>
<p>항상 <code>write()</code> 작업의 결과를 확인하세요:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> result = async-&gt;write(...);</div>
<div class="line"><span class="keywordflow">if</span> (!result.is_ok()) {</div>
<div class="line">    <span class="comment">// 대안: 동기로 쓰거나 드롭</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md227"></a>
4. 생명주기 관리</h2>
<ul>
<li>쓰기 전에 <code>start()</code> 호출</li>
<li>모든 메시지가 기록되어야 하면 <code>stop()</code> 전에 <code>flush()</code> 호출</li>
<li>자동 정리를 위해 RAII 패턴 사용</li>
</ul>
<h2><a class="anchor" id="autotoc_md228"></a>
5. 스레드 안전성 고려사항</h2>
<ul>
<li><code>async_writer</code>는 쓰기에 대해 스레드 안전</li>
<li><code>start()</code>/<code>stop()</code>을 동시에 호출하지 않기</li>
<li>설정 변경 시 외부 동기화 사용</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md230"></a>
마이그레이션 가이드</h1>
<h2><a class="anchor" id="autotoc_md231"></a>
동기에서 async_writer로</h2>
<p><b>이전:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>);</div>
<div class="line">writer-&gt;write(level, message, file, line, func, timestamp);</div>
</div><!-- fragment --><p><b>이후:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> async = std::make_unique&lt;async_writer&gt;(std::move(writer));</div>
<div class="line">async-&gt;start();</div>
<div class="line">async-&gt;write(level, message, file, line, func, timestamp);</div>
<div class="line"><span class="comment">// 잊지 마세요: 종료 시 async-&gt;stop()</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md232"></a>
큐 가득 참 마이그레이션</h2>
<p>큐 가득 참 에러가 발생하면:</p>
<ol type="1">
<li><b>큐 크기 증가:</b> <div class="fragment"><div class="line">async_writer(writer, 50000);  <span class="comment">// 기본값의 5배</span></div>
</div><!-- fragment --></li>
<li><b>백프레셔 처리 추가:</b> <div class="fragment"><div class="line"><span class="keywordflow">while</span> (!async-&gt;write(...).is_ok()) {</div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(1));</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>극단적인 경우 <b>high_performance_async_writer</b> 고려</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md234"></a>
관련 문서</h1>
<ul>
<li><a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2advanced_2CUSTOM__WRITERS__KO.html">커스텀 Writers 가이드</a> - 커스텀 writer 구현체 생성</li>
<li><a class="el" href="ARCHITECTURE__KO_8md.html">아키텍처 개요</a> - 시스템 아키텍처 및 설계</li>
<li><a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2BENCHMARKS__KO.html">성능 벤치마크</a> - 상세 성능 분석</li>
<li><a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2integration_2THREAD__SYSTEM__KO.html">Thread System 통합</a> - 스레드 시스템 통합</li>
</ul>
<hr  />
<p><b>메인테이너:</b> <a href="#" onclick="location.href='mai'+'lto:'+'kce'+'no'+'n@n'+'av'+'er.'+'co'+'m'; return false;">kceno<span class="obfuscator">.nosp@m.</span>n@na<span class="obfuscator">.nosp@m.</span>ver.c<span class="obfuscator">.nosp@m.</span>om</a> <b>이슈 트래커:</b> <a href="https://github.com/kcenon/logger_system/issues">GitHub Issues</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Jan 11 2026 05:48:06 for Logger System by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
