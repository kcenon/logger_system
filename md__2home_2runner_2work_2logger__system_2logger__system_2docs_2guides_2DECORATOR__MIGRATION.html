<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Logger System: Decorator Pattern Writer Migration Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Logger System<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-performance C++20 thread-safe logging system with asynchronous capabilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__2home_2runner_2work_2logger__system_2logger__system_2docs_2guides_2DECORATOR__MIGRATION.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Decorator Pattern Writer Migration Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md1328"></a> <b>Version</b>: 4.0.0 <b>Last Updated</b>: 2026-01-22</p>
<h1><a class="anchor" id="autotoc_md1329"></a>
Table of Contents</h1>
<ol type="1">
<li>Overview</li>
<li>New Architecture</li>
<li>Built-in Decorators</li>
<li>Migrating Custom Writers</li>
<li>Composing Decorators</li>
<li>Best Practices</li>
<li>Troubleshooting</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md1331"></a>
Overview</h1>
<p>Version 4.0.0 introduces a decorator pattern-based writer architecture that separates cross-cutting concerns (filtering, buffering, formatting) from destination-specific logic (console, file, network output).</p>
<h2><a class="anchor" id="autotoc_md1332"></a>
Why Decorator Pattern?</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Problem (v3.x)   </th><th class="markdownTableHeadNone">Solution (v4.0)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">~70% code duplication across writers   </td><td class="markdownTableBodyNone">Each concern implemented once in decorators    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Writers had multiple responsibilities   </td><td class="markdownTableBodyNone">Single Responsibility Principle enforced    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Hard to test individual features   </td><td class="markdownTableBodyNone">Each decorator independently testable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Tight coupling between concerns   </td><td class="markdownTableBodyNone">Loose coupling via composition   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md1333"></a>
Key Components</h2>
<div class="fragment"><div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│                    Decorator Writers                         │</div>
<div class="line">│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │</div>
<div class="line">│  │ formatted   │→ │ buffered    │→ │ filtered    │→ [Leaf]  │</div>
<div class="line">│  └─────────────┘  └─────────────┘  └─────────────┘          │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
<div class="line">                              ↓</div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│                      Leaf Writers                            │</div>
<div class="line">│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │</div>
<div class="line">│  │ console     │  │ file        │  │ network     │          │</div>
<div class="line">│  └─────────────┘  └─────────────┘  └─────────────┘          │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md1335"></a>
New Architecture</h1>
<h2><a class="anchor" id="autotoc_md1336"></a>
Base Classes</h2>
<h3><a class="anchor" id="autotoc_md1337"></a>
&lt;tt&gt;log_writer_interface&lt;/tt&gt;</h3>
<p>The core interface that all writers must implement:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>log_writer_interface {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> common::VoidResult write(<span class="keyword">const</span> log_entry&amp; entry) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> common::VoidResult flush() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::string get_name() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> is_healthy() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> ~log_writer_interface() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1338"></a>
&lt;tt&gt;decorator_writer_base&lt;/tt&gt;</h3>
<p>Abstract base class for decorators that eliminates boilerplate:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>decorator_writer_base : <span class="keyword">public</span> log_writer_interface, <span class="keyword">public</span> decorator_writer_tag {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> decorator_writer_base(std::unique_ptr&lt;log_writer_interface&gt; wrapped,</div>
<div class="line">                                   std::string_view decorator_name);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Must be implemented by derived classes</span></div>
<div class="line">    common::VoidResult write(<span class="keyword">const</span> log_entry&amp; entry) <span class="keyword">override</span> = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Default implementations that delegate to wrapped writer</span></div>
<div class="line">    common::VoidResult flush() <span class="keyword">override</span>;</div>
<div class="line">    std::string get_name() <span class="keyword">const override</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> is_healthy() <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    log_writer_interface&amp; wrapped() noexcept;</div>
<div class="line">    const log_writer_interface&amp; wrapped() const noexcept;</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md1340"></a>
Built-in Decorators</h1>
<h2><a class="anchor" id="autotoc_md1341"></a>
&lt;tt&gt;filtered_writer&lt;/tt&gt;</h2>
<p>Filters log entries before passing to the wrapped writer:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/filtered_writer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;kcenon/logger/filters/log_filter.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Only write errors and above</span></div>
<div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;filtered_writer&gt;(</div>
<div class="line">    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;errors.log&quot;</span>),</div>
<div class="line">    std::make_unique&lt;filters::level_filter&gt;(log_level::error)</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use composite filter for complex logic</span></div>
<div class="line"><span class="keyword">auto</span> composite = std::make_unique&lt;filters::composite_filter&gt;(</div>
<div class="line">    filters::composite_filter::logic_type::AND</div>
<div class="line">);</div>
<div class="line">composite-&gt;add_filter(std::make_unique&lt;filters::level_filter&gt;(log_level::info));</div>
<div class="line">composite-&gt;add_filter(std::make_unique&lt;filters::regex_filter&gt;(<span class="stringliteral">&quot;security&quot;</span>, <span class="keyword">true</span>));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> security_writer = std::make_unique&lt;filtered_writer&gt;(</div>
<div class="line">    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;security.log&quot;</span>),</div>
<div class="line">    std::move(composite)</div>
<div class="line">);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1342"></a>
&lt;tt&gt;buffered_writer&lt;/tt&gt;</h2>
<p>Buffers log entries before writing to improve performance:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/buffered_writer.h&gt;</span></div>
<div class="line"> </div>
<div class="line">buffered_writer::config config;</div>
<div class="line">config.max_buffer_size = 100;  <span class="comment">// Flush after 100 entries</span></div>
<div class="line">config.flush_interval = std::chrono::seconds(5);  <span class="comment">// Or flush every 5 seconds</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;buffered_writer&gt;(</div>
<div class="line">    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>),</div>
<div class="line">    config</div>
<div class="line">);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1343"></a>
&lt;tt&gt;formatted_writer&lt;/tt&gt;</h2>
<p>Applies formatting before writing:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/formatted_writer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;kcenon/logger/formatters/json_formatter.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;formatted_writer&gt;(</div>
<div class="line">    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;app.json&quot;</span>),</div>
<div class="line">    std::make_unique&lt;json_formatter&gt;()</div>
<div class="line">);</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md1345"></a>
Migrating Custom Writers</h1>
<h2><a class="anchor" id="autotoc_md1346"></a>
Before (v3.x): Monolithic Writer</h2>
<div class="fragment"><div class="line"><span class="comment">// Old approach: everything in one class</span></div>
<div class="line"><span class="keyword">class </span>my_custom_writer : <span class="keyword">public</span> base_writer {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    common::VoidResult write(<span class="keyword">const</span> log_entry&amp; entry)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Check filter (duplicated logic)</span></div>
<div class="line">        <span class="keywordflow">if</span> (!should_log(entry)) <span class="keywordflow">return</span> {};</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Format message (duplicated logic)</span></div>
<div class="line">        <span class="keyword">auto</span> formatted = format_entry(entry);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Buffer if needed (duplicated logic)</span></div>
<div class="line">        buffer_.push_back(formatted);</div>
<div class="line">        <span class="keywordflow">if</span> (buffer_.size() &gt;= buffer_size_) {</div>
<div class="line">            flush_buffer();</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Actual custom output</span></div>
<div class="line">        send_to_my_destination(formatted);</div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;std::string&gt; buffer_;</div>
<div class="line">    <span class="keywordtype">size_t</span> buffer_size_;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1347"></a>
After (v4.0): Focused Leaf Writer</h2>
<div class="fragment"><div class="line"><span class="comment">// New approach: only destination-specific logic</span></div>
<div class="line"><span class="keyword">class </span>my_custom_writer : <span class="keyword">public</span> thread_safe_writer, <span class="keyword">public</span> sync_writer_tag {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> my_custom_writer(<span class="keyword">const</span> std::string&amp; destination)</div>
<div class="line">        : destination_(destination) {}</div>
<div class="line"> </div>
<div class="line">    std::string get_name()<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;my_custom&quot;</span>; }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    common::VoidResult write_entry_impl(<span class="keyword">const</span> log_entry&amp; entry)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Only the custom output logic</span></div>
<div class="line">        <span class="keywordflow">return</span> send_to_my_destination(entry);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    common::VoidResult flush_impl()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> flush_my_destination();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::string destination_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Compose with decorators for additional functionality</span></div>
<div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;formatted_writer&gt;(</div>
<div class="line">    std::make_unique&lt;buffered_writer&gt;(</div>
<div class="line">        std::make_unique&lt;filtered_writer&gt;(</div>
<div class="line">            std::make_unique&lt;my_custom_writer&gt;(<span class="stringliteral">&quot;my-endpoint&quot;</span>),</div>
<div class="line">            std::make_unique&lt;level_filter&gt;(log_level::info)</div>
<div class="line">        ),</div>
<div class="line">        buffered_writer::config{.max_buffer_size = 50}</div>
<div class="line">    ),</div>
<div class="line">    std::make_unique&lt;json_formatter&gt;()</div>
<div class="line">);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1348"></a>
Creating a Custom Decorator</h2>
<p>If you need custom cross-cutting behavior, extend <code>decorator_writer_base</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>rate_limiting_writer : <span class="keyword">public</span> decorator_writer_base {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    rate_limiting_writer(std::unique_ptr&lt;log_writer_interface&gt; wrapped,</div>
<div class="line">                         <span class="keywordtype">size_t</span> max_per_second)</div>
<div class="line">        : decorator_writer_base(std::move(wrapped), <span class="stringliteral">&quot;rate_limited&quot;</span>),</div>
<div class="line">          max_per_second_(max_per_second) {}</div>
<div class="line"> </div>
<div class="line">    common::VoidResult write(<span class="keyword">const</span> log_entry&amp; entry)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keyword">auto</span> now = std::chrono::steady_clock::now();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Reset counter every second</span></div>
<div class="line">        <span class="keywordflow">if</span> (now - window_start_ &gt;= std::chrono::seconds(1)) {</div>
<div class="line">            window_start_ = now;</div>
<div class="line">            count_ = 0;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Drop if rate exceeded</span></div>
<div class="line">        <span class="keywordflow">if</span> (count_ &gt;= max_per_second_) {</div>
<div class="line">            <span class="keywordflow">return</span> {};  <span class="comment">// Silently drop</span></div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        ++count_;</div>
<div class="line">        <span class="keywordflow">return</span> wrapped().write(entry);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">size_t</span> max_per_second_;</div>
<div class="line">    <span class="keywordtype">size_t</span> count_ = 0;</div>
<div class="line">    std::chrono::steady_clock::time_point window_start_;</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md1350"></a>
Composing Decorators</h1>
<h2><a class="anchor" id="autotoc_md1351"></a>
Order Matters</h2>
<p>Decorators are applied in reverse order of construction (innermost first):</p>
<div class="fragment"><div class="line"><span class="comment">// Execution order: filter → buffer → format → file</span></div>
<div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;formatted_writer&gt;(      <span class="comment">// 4. Format output</span></div>
<div class="line">    std::make_unique&lt;buffered_writer&gt;(                  <span class="comment">// 3. Buffer entries</span></div>
<div class="line">        std::make_unique&lt;filtered_writer&gt;(              <span class="comment">// 2. Filter entries</span></div>
<div class="line">            std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>),   <span class="comment">// 1. Write to file</span></div>
<div class="line">            std::make_unique&lt;level_filter&gt;(log_level::info)</div>
<div class="line">        ),</div>
<div class="line">        buffered_writer::config{.max_buffer_size = 100}</div>
<div class="line">    ),</div>
<div class="line">    std::make_unique&lt;json_formatter&gt;()</div>
<div class="line">);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1352"></a>
Recommended Order</h2>
<ol type="1">
<li><b>Filtering</b> (earliest) - Drop unwanted entries before any processing</li>
<li><b>Buffering</b> - Batch entries for efficiency</li>
<li><b>Formatting</b> - Transform entries just before output</li>
<li><b>Output</b> (leaf writer) - Write to destination</li>
</ol>
<h2><a class="anchor" id="autotoc_md1353"></a>
Using &lt;tt&gt;logger_builder&lt;/tt&gt;</h2>
<p>The builder automatically applies common decorators:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> logger = logger_builder()</div>
<div class="line">    .add_writer(<span class="stringliteral">&quot;file&quot;</span>, std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>))</div>
<div class="line">    .add_level_filter(log_level::info)   <span class="comment">// Adds filtered_writer</span></div>
<div class="line">    .with_batch_writing(<span class="keyword">true</span>)             <span class="comment">// Wraps with batch_writer</span></div>
<div class="line">    .with_formatter(std::make_unique&lt;json_formatter&gt;())  <span class="comment">// Adds formatted_writer</span></div>
<div class="line">    .build();</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md1355"></a>
Best Practices</h1>
<h2><a class="anchor" id="autotoc_md1356"></a>
1. Keep Leaf Writers Simple</h2>
<p>Leaf writers should only handle destination-specific I/O:</p>
<div class="fragment"><div class="line"><span class="comment">// Good: Focused on one thing</span></div>
<div class="line"><span class="keyword">class </span>kafka_writer : <span class="keyword">public</span> thread_safe_writer {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    common::VoidResult write_entry_impl(<span class="keyword">const</span> log_entry&amp; entry)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> kafka_client_.send(topic_, entry.formatted_message());</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Bad: Too many responsibilities</span></div>
<div class="line"><span class="keyword">class </span>kafka_writer : <span class="keyword">public</span> thread_safe_writer {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    common::VoidResult write_entry_impl(<span class="keyword">const</span> log_entry&amp; entry)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (entry.level() &lt; min_level_) <span class="keywordflow">return</span> {};  <span class="comment">// Should be filtered_writer</span></div>
<div class="line">        <span class="keyword">auto</span> json = to_json(entry);                  <span class="comment">// Should be formatted_writer</span></div>
<div class="line">        buffer_.push(json);                          <span class="comment">// Should be buffered_writer</span></div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1357"></a>
2. Use Category Tags</h2>
<p>Mark your writers with appropriate category tags:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>my_sync_writer : <span class="keyword">public</span> thread_safe_writer, <span class="keyword">public</span> sync_writer_tag { ... };</div>
<div class="line"><span class="keyword">class </span>my_async_writer : <span class="keyword">public</span> queued_writer_base, <span class="keyword">public</span> async_writer_tag { ... };</div>
<div class="line"><span class="keyword">class </span>my_decorator : <span class="keyword">public</span> decorator_writer_base, <span class="keyword">public</span> decorator_writer_tag { ... };</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1358"></a>
3. Handle Errors Gracefully</h2>
<p>Decorators should propagate errors from wrapped writers:</p>
<div class="fragment"><div class="line">common::VoidResult write(<span class="keyword">const</span> log_entry&amp; entry)<span class="keyword"> override </span>{</div>
<div class="line">    <span class="comment">// Do pre-processing</span></div>
<div class="line">    <span class="keyword">auto</span> result = wrapped().write(entry);</div>
<div class="line">    <span class="keywordflow">if</span> (result.is_err()) {</div>
<div class="line">        <span class="keywordflow">return</span> result;  <span class="comment">// Propagate error</span></div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Do post-processing</span></div>
<div class="line">    <span class="keywordflow">return</span> {};</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1359"></a>
4. Ensure Thread Safety</h2>
<p>If your decorator maintains state, protect it:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>stateful_decorator : <span class="keyword">public</span> decorator_writer_base {</div>
<div class="line">    common::VoidResult write(<span class="keyword">const</span> log_entry&amp; entry)<span class="keyword"> override </span>{</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">        <span class="comment">// Access mutable state safely</span></div>
<div class="line">        <span class="keywordflow">return</span> wrapped().write(entry);</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::mutex mutex_;</div>
<div class="line">    <span class="comment">// mutable state...</span></div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md1361"></a>
Troubleshooting</h1>
<h2><a class="anchor" id="autotoc_md1362"></a>
Common Issues</h2>
<h3><a class="anchor" id="autotoc_md1363"></a>
"Writer not receiving entries"</h3>
<p>Check decorator composition order. Filters should be innermost:</p>
<div class="fragment"><div class="line"><span class="comment">// Wrong: Filter after buffer means filtered entries still buffered</span></div>
<div class="line"><span class="keyword">auto</span> wrong = std::make_unique&lt;filtered_writer&gt;(</div>
<div class="line">    std::make_unique&lt;buffered_writer&gt;(...),</div>
<div class="line">    filter</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Right: Filter before buffer</span></div>
<div class="line"><span class="keyword">auto</span> right = std::make_unique&lt;buffered_writer&gt;(</div>
<div class="line">    std::make_unique&lt;filtered_writer&gt;(..., filter),</div>
<div class="line">    config</div>
<div class="line">);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1364"></a>
"Entries not being formatted"</h3>
<p>Ensure <code>formatted_writer</code> wraps the leaf writer:</p>
<div class="fragment"><div class="line"><span class="comment">// Wrong: Formatting lost because it&#39;s wrapped by buffer</span></div>
<div class="line"><span class="keyword">auto</span> wrong = std::make_unique&lt;buffered_writer&gt;(</div>
<div class="line">    std::make_unique&lt;formatted_writer&gt;(...),</div>
<div class="line">    config</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Right: Format just before output</span></div>
<div class="line"><span class="keyword">auto</span> right = std::make_unique&lt;formatted_writer&gt;(</div>
<div class="line">    std::make_unique&lt;buffered_writer&gt;(..., config),</div>
<div class="line">    formatter</div>
<div class="line">);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1365"></a>
"Flush not working"</h3>
<p>Call <code>flush()</code> on the outermost decorator:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> outermost = std::make_unique&lt;formatted_writer&gt;(</div>
<div class="line">    std::make_unique&lt;buffered_writer&gt;(inner, config),</div>
<div class="line">    formatter</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This flushes all layers</span></div>
<div class="line">outermost-&gt;flush();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1366"></a>
Migration Checklist</h2>
<ul>
<li>[ ] Identify cross-cutting concerns in existing writers</li>
<li>[ ] Separate destination logic from filtering/buffering/formatting</li>
<li>[ ] Create simple leaf writers inheriting from <code>thread_safe_writer</code></li>
<li>[ ] Use built-in decorators for common functionality</li>
<li>[ ] Create custom decorators only for unique cross-cutting needs</li>
<li>[ ] Update tests to verify decorator composition</li>
<li>[ ] Benchmark to ensure no performance regression</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md1368"></a>
Related Documentation</h1>
<ul>
<li><a href="../API_REFERENCE.md#writers">API Reference - Writers</a></li>
<li><a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2ARCHITECTURE.html">Architecture Overview</a></li>
<li><a href="../CHANGELOG.md#400---unreleased">Changelog v4.0.0</a></li>
<li><a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2guides_2BEST__PRACTICES.html">Best Practices</a></li>
</ul>
<hr  />
<p><em>Part of Logger System v4.0.0 documentation</em> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jan 23 2026 12:22:37 for Logger System by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
