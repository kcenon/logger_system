<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Logger System: Decorator Pattern Writer Migration Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Logger System<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-performance C++20 thread-safe logging system with asynchronous capabilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__2home_2runner_2work_2logger__system_2logger__system_2docs_2guides_2DECORATOR__MIGRATION.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Decorator Pattern Writer Migration Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md1530"></a> <b>Version</b>: 0.4.0.0 <b>Last Updated</b>: 2026-01-22</p>
<h1><a class="anchor" id="autotoc_md1531"></a>
Table of Contents</h1>
<ol type="1">
<li>Overview</li>
<li>New Architecture</li>
<li>Built-in Decorators</li>
<li>Migrating Custom Writers</li>
<li>Composing Decorators</li>
<li>Deprecation Timeline and Legacy Patterns</li>
<li>Best Practices</li>
<li>Troubleshooting</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md1533"></a>
Overview</h1>
<p>Version 4.0.0 introduces a decorator pattern-based writer architecture that separates cross-cutting concerns (filtering, buffering, formatting) from destination-specific logic (console, file, network output).</p>
<h2><a class="anchor" id="autotoc_md1534"></a>
Why Decorator Pattern?</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Problem (v3.x)   </th><th class="markdownTableHeadNone">Solution (v4.0)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">~70% code duplication across writers   </td><td class="markdownTableBodyNone">Each concern implemented once in decorators    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Writers had multiple responsibilities   </td><td class="markdownTableBodyNone">Single Responsibility Principle enforced    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Hard to test individual features   </td><td class="markdownTableBodyNone">Each decorator independently testable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Tight coupling between concerns   </td><td class="markdownTableBodyNone">Loose coupling via composition   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md1535"></a>
Key Components</h2>
<div class="fragment"><div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│                    Decorator Writers                         │</div>
<div class="line">│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │</div>
<div class="line">│  │ formatted   │→ │ buffered    │→ │ filtered    │→ [Leaf]  │</div>
<div class="line">│  └─────────────┘  └─────────────┘  └─────────────┘          │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
<div class="line">                              ↓</div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│                      Leaf Writers                            │</div>
<div class="line">│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │</div>
<div class="line">│  │ console     │  │ file        │  │ network     │          │</div>
<div class="line">│  └─────────────┘  └─────────────┘  └─────────────┘          │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md1537"></a>
New Architecture</h1>
<h2><a class="anchor" id="autotoc_md1538"></a>
Base Classes</h2>
<h3><a class="anchor" id="autotoc_md1539"></a>
&lt;tt&gt;log_writer_interface&lt;/tt&gt;</h3>
<p>The core interface that all writers must implement:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>log_writer_interface {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> common::VoidResult write(<span class="keyword">const</span> log_entry&amp; entry) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> common::VoidResult flush() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::string get_name() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> is_healthy() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> ~log_writer_interface() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1540"></a>
&lt;tt&gt;decorator_writer_base&lt;/tt&gt;</h3>
<p>Abstract base class for decorators that eliminates boilerplate:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>decorator_writer_base : <span class="keyword">public</span> log_writer_interface, <span class="keyword">public</span> decorator_writer_tag {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> decorator_writer_base(std::unique_ptr&lt;log_writer_interface&gt; wrapped,</div>
<div class="line">                                   std::string_view decorator_name);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Must be implemented by derived classes</span></div>
<div class="line">    common::VoidResult write(<span class="keyword">const</span> log_entry&amp; entry) <span class="keyword">override</span> = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Default implementations that delegate to wrapped writer</span></div>
<div class="line">    common::VoidResult flush() <span class="keyword">override</span>;</div>
<div class="line">    std::string get_name() <span class="keyword">const override</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> is_healthy() <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    log_writer_interface&amp; wrapped() noexcept;</div>
<div class="line">    const log_writer_interface&amp; wrapped() const noexcept;</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md1542"></a>
Built-in Decorators</h1>
<h2><a class="anchor" id="autotoc_md1543"></a>
&lt;tt&gt;filtered_writer&lt;/tt&gt;</h2>
<p>Filters log entries before passing to the wrapped writer:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/filtered_writer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;kcenon/logger/filters/log_filter.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Only write errors and above</span></div>
<div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;filtered_writer&gt;(</div>
<div class="line">    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;errors.log&quot;</span>),</div>
<div class="line">    std::make_unique&lt;filters::level_filter&gt;(log_level::error)</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use composite filter for complex logic</span></div>
<div class="line"><span class="keyword">auto</span> composite = std::make_unique&lt;filters::composite_filter&gt;(</div>
<div class="line">    filters::composite_filter::logic_type::AND</div>
<div class="line">);</div>
<div class="line">composite-&gt;add_filter(std::make_unique&lt;filters::level_filter&gt;(log_level::info));</div>
<div class="line">composite-&gt;add_filter(std::make_unique&lt;filters::regex_filter&gt;(<span class="stringliteral">&quot;security&quot;</span>, <span class="keyword">true</span>));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> security_writer = std::make_unique&lt;filtered_writer&gt;(</div>
<div class="line">    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;security.log&quot;</span>),</div>
<div class="line">    std::move(composite)</div>
<div class="line">);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1544"></a>
&lt;tt&gt;buffered_writer&lt;/tt&gt;</h2>
<p>Buffers log entries before writing to improve performance:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/buffered_writer.h&gt;</span></div>
<div class="line"> </div>
<div class="line">buffered_writer::config config;</div>
<div class="line">config.max_buffer_size = 100;  <span class="comment">// Flush after 100 entries</span></div>
<div class="line">config.flush_interval = std::chrono::seconds(5);  <span class="comment">// Or flush every 5 seconds</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;buffered_writer&gt;(</div>
<div class="line">    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>),</div>
<div class="line">    config</div>
<div class="line">);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1545"></a>
&lt;tt&gt;formatted_writer&lt;/tt&gt;</h2>
<p>Applies formatting before writing:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/formatted_writer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;kcenon/logger/formatters/json_formatter.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;formatted_writer&gt;(</div>
<div class="line">    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;app.json&quot;</span>),</div>
<div class="line">    std::make_unique&lt;json_formatter&gt;()</div>
<div class="line">);</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md1547"></a>
Migrating Custom Writers</h1>
<h2><a class="anchor" id="autotoc_md1548"></a>
Before (v3.x): Monolithic Writer</h2>
<div class="fragment"><div class="line"><span class="comment">// Old approach: everything in one class</span></div>
<div class="line"><span class="keyword">class </span>my_custom_writer : <span class="keyword">public</span> base_writer {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    common::VoidResult write(<span class="keyword">const</span> log_entry&amp; entry)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Check filter (duplicated logic)</span></div>
<div class="line">        <span class="keywordflow">if</span> (!should_log(entry)) <span class="keywordflow">return</span> {};</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Format message (duplicated logic)</span></div>
<div class="line">        <span class="keyword">auto</span> formatted = format_entry(entry);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Buffer if needed (duplicated logic)</span></div>
<div class="line">        buffer_.push_back(formatted);</div>
<div class="line">        <span class="keywordflow">if</span> (buffer_.size() &gt;= buffer_size_) {</div>
<div class="line">            flush_buffer();</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Actual custom output</span></div>
<div class="line">        send_to_my_destination(formatted);</div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;std::string&gt; buffer_;</div>
<div class="line">    <span class="keywordtype">size_t</span> buffer_size_;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1549"></a>
After (v4.0): Focused Leaf Writer</h2>
<div class="fragment"><div class="line"><span class="comment">// New approach: only destination-specific logic</span></div>
<div class="line"><span class="keyword">class </span>my_custom_writer : <span class="keyword">public</span> thread_safe_writer, <span class="keyword">public</span> sync_writer_tag {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> my_custom_writer(<span class="keyword">const</span> std::string&amp; destination)</div>
<div class="line">        : destination_(destination) {}</div>
<div class="line"> </div>
<div class="line">    std::string get_name()<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;my_custom&quot;</span>; }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    common::VoidResult write_entry_impl(<span class="keyword">const</span> log_entry&amp; entry)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Only the custom output logic</span></div>
<div class="line">        <span class="keywordflow">return</span> send_to_my_destination(entry);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    common::VoidResult flush_impl()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> flush_my_destination();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::string destination_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Compose with decorators for additional functionality</span></div>
<div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;formatted_writer&gt;(</div>
<div class="line">    std::make_unique&lt;buffered_writer&gt;(</div>
<div class="line">        std::make_unique&lt;filtered_writer&gt;(</div>
<div class="line">            std::make_unique&lt;my_custom_writer&gt;(<span class="stringliteral">&quot;my-endpoint&quot;</span>),</div>
<div class="line">            std::make_unique&lt;level_filter&gt;(log_level::info)</div>
<div class="line">        ),</div>
<div class="line">        buffered_writer::config{.max_buffer_size = 50}</div>
<div class="line">    ),</div>
<div class="line">    std::make_unique&lt;json_formatter&gt;()</div>
<div class="line">);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1550"></a>
Creating a Custom Decorator</h2>
<p>If you need custom cross-cutting behavior, extend <code>decorator_writer_base</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>rate_limiting_writer : <span class="keyword">public</span> decorator_writer_base {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    rate_limiting_writer(std::unique_ptr&lt;log_writer_interface&gt; wrapped,</div>
<div class="line">                         <span class="keywordtype">size_t</span> max_per_second)</div>
<div class="line">        : decorator_writer_base(std::move(wrapped), <span class="stringliteral">&quot;rate_limited&quot;</span>),</div>
<div class="line">          max_per_second_(max_per_second) {}</div>
<div class="line"> </div>
<div class="line">    common::VoidResult write(<span class="keyword">const</span> log_entry&amp; entry)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keyword">auto</span> now = std::chrono::steady_clock::now();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Reset counter every second</span></div>
<div class="line">        <span class="keywordflow">if</span> (now - window_start_ &gt;= std::chrono::seconds(1)) {</div>
<div class="line">            window_start_ = now;</div>
<div class="line">            count_ = 0;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Drop if rate exceeded</span></div>
<div class="line">        <span class="keywordflow">if</span> (count_ &gt;= max_per_second_) {</div>
<div class="line">            <span class="keywordflow">return</span> {};  <span class="comment">// Silently drop</span></div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        ++count_;</div>
<div class="line">        <span class="keywordflow">return</span> wrapped().write(entry);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">size_t</span> max_per_second_;</div>
<div class="line">    <span class="keywordtype">size_t</span> count_ = 0;</div>
<div class="line">    std::chrono::steady_clock::time_point window_start_;</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md1552"></a>
Composing Decorators</h1>
<h2><a class="anchor" id="autotoc_md1553"></a>
Order Matters</h2>
<p>Decorators are applied in reverse order of construction (innermost first):</p>
<div class="fragment"><div class="line"><span class="comment">// Execution order: filter → buffer → format → file</span></div>
<div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;formatted_writer&gt;(      <span class="comment">// 4. Format output</span></div>
<div class="line">    std::make_unique&lt;buffered_writer&gt;(                  <span class="comment">// 3. Buffer entries</span></div>
<div class="line">        std::make_unique&lt;filtered_writer&gt;(              <span class="comment">// 2. Filter entries</span></div>
<div class="line">            std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>),   <span class="comment">// 1. Write to file</span></div>
<div class="line">            std::make_unique&lt;level_filter&gt;(log_level::info)</div>
<div class="line">        ),</div>
<div class="line">        buffered_writer::config{.max_buffer_size = 100}</div>
<div class="line">    ),</div>
<div class="line">    std::make_unique&lt;json_formatter&gt;()</div>
<div class="line">);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1554"></a>
Recommended Order</h2>
<ol type="1">
<li><b>Filtering</b> (earliest) - Drop unwanted entries before any processing</li>
<li><b>Buffering</b> - Batch entries for efficiency</li>
<li><b>Formatting</b> - Transform entries just before output</li>
<li><b>Output</b> (leaf writer) - Write to destination</li>
</ol>
<h2><a class="anchor" id="autotoc_md1555"></a>
Using &lt;tt&gt;writer_builder&lt;/tt&gt; (Recommended)</h2>
<p><b>Since v4.1.0</b>, the <code>writer_builder</code> provides a fluent API for composing writers with decorators:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/builders/writer_builder.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Simple file writer</span></div>
<div class="line"><span class="keyword">auto</span> writer = writer_builder()</div>
<div class="line">    .file(<span class="stringliteral">&quot;app.log&quot;</span>)</div>
<div class="line">    .build();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Production setup: async + buffered</span></div>
<div class="line"><span class="keyword">auto</span> production_writer = writer_builder()</div>
<div class="line">    .file(<span class="stringliteral">&quot;app.log&quot;</span>)</div>
<div class="line">    .buffered(500)       <span class="comment">// Buffer 500 entries</span></div>
<div class="line">    .async(20000)        <span class="comment">// Queue size 20000</span></div>
<div class="line">    .build();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Filtered console (warnings and above)</span></div>
<div class="line"><span class="keyword">auto</span> console_writer = writer_builder()</div>
<div class="line">    .console()</div>
<div class="line">    .filtered(std::make_unique&lt;level_filter&gt;(log_level::warning))</div>
<div class="line">    .build();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Encrypted logging with buffering</span></div>
<div class="line"><span class="preprocessor">#ifdef LOGGER_WITH_ENCRYPTION</span></div>
<div class="line"><span class="keyword">auto</span> secure_writer = writer_builder()</div>
<div class="line">    .file(<span class="stringliteral">&quot;secure.log.enc&quot;</span>)</div>
<div class="line">    .encrypted(key)</div>
<div class="line">    .buffered(100)</div>
<div class="line">    .async()</div>
<div class="line">    .build();</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p><b>Benefits of <code>writer_builder</code>:</b></p><ul>
<li><b>Readable</b>: Fluent API is self-documenting</li>
<li><b>Type-safe</b>: Compile-time validation</li>
<li><b>Consistent order</b>: Decorators applied in optimal order</li>
<li><b>Error-proof</b>: No manual nesting required</li>
</ul>
<p>See <a href="../../examples/writer_builder_example.cpp">writer_builder_example.cpp</a> for complete examples.</p>
<h2><a class="anchor" id="autotoc_md1556"></a>
Using &lt;tt&gt;logger_builder&lt;/tt&gt;</h2>
<p>The logger builder accepts writers created by <code>writer_builder</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> logger = logger_builder()</div>
<div class="line">    .add_writer(<span class="stringliteral">&quot;file&quot;</span>, writer_builder().file(<span class="stringliteral">&quot;app.log&quot;</span>).build())</div>
<div class="line">    .add_level_filter(log_level::info)   <span class="comment">// Adds filtered_writer</span></div>
<div class="line">    .with_batch_writing(<span class="keyword">true</span>)             <span class="comment">// Wraps with batch_writer</span></div>
<div class="line">    .with_formatter(std::make_unique&lt;json_formatter&gt;())  <span class="comment">// Adds formatted_writer</span></div>
<div class="line">    .build();</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md1558"></a>
Deprecation Timeline and Legacy Patterns</h1>
<h2><a class="anchor" id="autotoc_md1559"></a>
Deprecated Writer Patterns</h2>
<p>The following legacy writer patterns are <b>deprecated</b> as of v4.1.0:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Legacy Pattern   </th><th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Replacement    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>rotating_file_writer</code>   </td><td class="markdownTableBodyNone">Deprecated (v4.1)   </td><td class="markdownTableBodyNone"><code>writer_builder().file().buffered()</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>async_file_writer</code>   </td><td class="markdownTableBodyNone">Deprecated (v4.1)   </td><td class="markdownTableBodyNone"><code>writer_builder().file().async()</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Combined writer classes   </td><td class="markdownTableBodyNone">Deprecated (v4.1)   </td><td class="markdownTableBodyNone"><code>writer_builder()</code> with decorator chain   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md1560"></a>
Timeline</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Version   </th><th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Action Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>4.0.0</b>   </td><td class="markdownTableBodyNone">Decorator pattern introduced   </td><td class="markdownTableBodyNone">Optional: Begin planning migration    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>4.1.0</b>   </td><td class="markdownTableBodyNone"><code>writer_builder</code> available   </td><td class="markdownTableBodyNone"><b>Recommended</b>: Migrate to builder API    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>4.1.0</b>   </td><td class="markdownTableBodyNone">Deprecation warnings added   </td><td class="markdownTableBodyNone">Legacy classes emit compile warnings    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>5.0.0</b>   </td><td class="markdownTableBodyNone">Legacy classes removed   </td><td class="markdownTableBodyNone"><b>Required</b>: Must use decorator pattern   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md1561"></a>
Migration Paths</h2>
<blockquote class="doxtable">
<p>&zwj;<b>Note</b>: All scenarios below show complete working examples. If you encounter issues during migration, see Troubleshooting. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md1562"></a>
Scenario 1: Simple File Writer</h3>
<p><b>Before (Deprecated)</b>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>);</div>
</div><!-- fragment --><p><b>After (Recommended)</b>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = writer_builder().file(<span class="stringliteral">&quot;app.log&quot;</span>).build();</div>
</div><!-- fragment --><p><b>Migration Steps</b>:</p><ol type="1">
<li>Replace <code>std::make_unique&lt;file_writer&gt;()</code> with <code>writer_builder().file()</code></li>
<li>Add <code>.build()</code> at the end</li>
<li>Test that logs are written correctly</li>
<li><b>Common Issue</b>: If entries aren't being written, ensure writer is added to logger with <code>add_writer()</code></li>
</ol>
<h3><a class="anchor" id="autotoc_md1563"></a>
Scenario 2: Rotating File Writer</h3>
<p><b>Before (Deprecated)</b>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;rotating_file_writer&gt;(</div>
<div class="line">    <span class="stringliteral">&quot;app.log&quot;</span>,</div>
<div class="line">    10 * 1024 * 1024,  <span class="comment">// 10MB max size</span></div>
<div class="line">    5                   <span class="comment">// 5 backup files</span></div>
<div class="line">);</div>
</div><!-- fragment --><p><b>After (Recommended)</b>: </p><div class="fragment"><div class="line"><span class="comment">// Note: rotating_file_writer is specialized, not yet fully replaced by decorators</span></div>
<div class="line"><span class="comment">// For now, continue using rotating_file_writer but expect future decorator-based replacement</span></div>
<div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;rotating_file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>, 10 * 1024 * 1024, 5);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Alternative: Use external log rotation tools (logrotate, etc.)</span></div>
<div class="line"><span class="keyword">auto</span> writer = writer_builder().file(<span class="stringliteral">&quot;app.log&quot;</span>).build();</div>
</div><!-- fragment --><p><b>Migration Steps</b>:</p><ol type="1">
<li>If file rotation is critical, continue using <code>rotating_file_writer</code> (not deprecated yet)</li>
<li>Consider external rotation tools (logrotate on Linux, log management services)</li>
<li>Plan for future migration when decorator-based rotation becomes available</li>
<li><b>Common Issue</b>: See Flush not working if rotation timing is incorrect</li>
</ol>
<h3><a class="anchor" id="autotoc_md1564"></a>
Scenario 3: Async + Encrypted Writer</h3>
<p><b>Before (Manual Nesting)</b>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;async_writer&gt;(</div>
<div class="line">    std::make_unique&lt;encrypted_writer&gt;(</div>
<div class="line">        std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;secure.log.enc&quot;</span>),</div>
<div class="line">        key</div>
<div class="line">    ),</div>
<div class="line">    10000  <span class="comment">// queue size</span></div>
<div class="line">);</div>
</div><!-- fragment --><p><b>After (Builder API)</b>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = writer_builder()</div>
<div class="line">    .file(<span class="stringliteral">&quot;secure.log.enc&quot;</span>)</div>
<div class="line">    .encrypted(key)</div>
<div class="line">    .async(10000)</div>
<div class="line">    .build();</div>
</div><!-- fragment --><p><b>Migration Steps</b>:</p><ol type="1">
<li>Replace innermost nesting (file_writer) with <code>.file()</code></li>
<li>Add <code>.encrypted()</code> for encryption decorator</li>
<li>Add <code>.async()</code> for async decorator (outermost)</li>
<li>Call <code>.build()</code> to construct the writer chain</li>
<li><b>Important</b>: Must call <code>start()</code> on async writer before use: <div class="fragment"><div class="line"><span class="keywordflow">if</span> (<span class="keyword">auto</span>* async_w = <span class="keyword">dynamic_cast&lt;</span>async_writer*<span class="keyword">&gt;</span>(writer.get())) {</div>
<div class="line">    async_w-&gt;start();</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><b>Common Issue</b>: If logs don't appear, check async writer is started. See Troubleshooting</li>
</ol>
<h3><a class="anchor" id="autotoc_md1565"></a>
Scenario 4: Buffered + Filtered Writer</h3>
<p><b>Before (Manual Nesting)</b>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;buffered_writer&gt;(</div>
<div class="line">    std::make_unique&lt;filtered_writer&gt;(</div>
<div class="line">        std::make_unique&lt;console_writer&gt;(),</div>
<div class="line">        std::make_unique&lt;level_filter&gt;(log_level::warning)</div>
<div class="line">    ),</div>
<div class="line">    buffered_writer::config{.max_buffer_size = 100}</div>
<div class="line">);</div>
</div><!-- fragment --><p><b>After (Builder API)</b>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = writer_builder()</div>
<div class="line">    .console()</div>
<div class="line">    .filtered(std::make_unique&lt;level_filter&gt;(log_level::warning))</div>
<div class="line">    .buffered(100)</div>
<div class="line">    .build();</div>
</div><!-- fragment --><p><b>Migration Steps</b>:</p><ol type="1">
<li>Start with core writer: <code>.console()</code></li>
<li>Add filter decorator: <code>.filtered(filter)</code> (applied first)</li>
<li>Add buffer decorator: <code>.buffered(size)</code> (applied after filter)</li>
<li>Build the chain: <code>.build()</code></li>
<li><b>Order Matters</b>: Filter → Buffer → Output (see Composing Decorators)</li>
<li><b>Common Issue</b>: Wrong decorator order. See Writer not receiving entries</li>
</ol>
<h3><a class="anchor" id="autotoc_md1566"></a>
Scenario 5: Multiple Decorators (Production Setup)</h3>
<p><b>Before (Complex Nesting)</b>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;formatted_writer&gt;(</div>
<div class="line">    std::make_unique&lt;async_writer&gt;(</div>
<div class="line">        std::make_unique&lt;buffered_writer&gt;(</div>
<div class="line">            std::make_unique&lt;filtered_writer&gt;(</div>
<div class="line">                std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;production.log&quot;</span>),</div>
<div class="line">                std::make_unique&lt;level_filter&gt;(log_level::info)</div>
<div class="line">            ),</div>
<div class="line">            buffered_writer::config{.max_buffer_size = 500}</div>
<div class="line">        ),</div>
<div class="line">        20000</div>
<div class="line">    ),</div>
<div class="line">    std::make_unique&lt;json_formatter&gt;()</div>
<div class="line">);</div>
</div><!-- fragment --><p><b>After (Fluent Builder)</b>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = writer_builder()</div>
<div class="line">    .file(<span class="stringliteral">&quot;production.log&quot;</span>)</div>
<div class="line">    .filtered(std::make_unique&lt;level_filter&gt;(log_level::info))</div>
<div class="line">    .buffered(500)</div>
<div class="line">    .formatted(std::make_unique&lt;json_formatter&gt;())</div>
<div class="line">    .async(20000)</div>
<div class="line">    .build();</div>
</div><!-- fragment --><p><b>Migration Steps</b>:</p><ol type="1">
<li>Identify all nested decorators (4 layers in this example)</li>
<li>Reverse the nesting order when using builder (innermost → outermost)</li>
<li>Core writer first: <code>.file()</code></li>
<li>Add decorators in order: filter → buffer → format → async</li>
<li>Start async writer after building (if using async)</li>
<li>Test thoroughly with actual log messages</li>
<li><b>Performance Tip</b>: This pattern provides ~4M msg/s throughput. See <a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2guides_2PERFORMANCE.html">Performance Guide</a></li>
<li><b>Common Issue</b>: If formatting fails, ensure formatter is compatible. See Entries not being formatted</li>
</ol>
<h3><a class="anchor" id="autotoc_md1567"></a>
Scenario 6: Custom Writer Integration</h3>
<p><b>Before (Inheritance)</b>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>my_combined_writer : <span class="keyword">public</span> base_writer {</div>
<div class="line">    <span class="comment">// 100+ lines of filtering, buffering, formatting logic</span></div>
<div class="line">    <span class="comment">// Mixed with custom destination logic</span></div>
<div class="line">};</div>
</div><!-- fragment --><p><b>After (Composition)</b>: </p><div class="fragment"><div class="line"><span class="comment">// 1. Create simple leaf writer (20-30 lines)</span></div>
<div class="line"><span class="keyword">class </span>my_destination_writer : <span class="keyword">public</span> thread_safe_writer {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::string get_name()<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;my_destination&quot;</span>; }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    common::VoidResult write_entry_impl(<span class="keyword">const</span> log_entry&amp; entry)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> send_to_my_destination(entry);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    common::VoidResult flush_impl()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> flush_my_destination();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 2. Compose with decorators</span></div>
<div class="line"><span class="keyword">auto</span> writer = writer_builder()</div>
<div class="line">    .custom(std::make_unique&lt;my_destination_writer&gt;())</div>
<div class="line">    .filtered(filter)</div>
<div class="line">    .buffered(100)</div>
<div class="line">    .async()</div>
<div class="line">    .build();</div>
</div><!-- fragment --><p><b>Migration Steps</b>:</p><ol type="1">
<li><b>Separate concerns</b>: Extract destination-specific I/O from cross-cutting logic</li>
<li><b>Create leaf writer</b>: Inherit from <code>thread_safe_writer</code> or <code>sync_writer_tag</code></li>
<li><b>Implement only I/O methods</b>: <code>write_entry_impl()</code>, <code>flush_impl()</code>, <code>get_name()</code></li>
<li><b>Remove duplicated logic</b>: Delete filtering, buffering, formatting from custom class</li>
<li><b>Use decorators</b>: Compose with <code>.filtered()</code>, <code>.buffered()</code>, <code>.async()</code> as needed</li>
<li><b>Benefits</b>: 70% less code, independently testable, reusable</li>
<li><b>Common Issue</b>: If custom writer doesn't compile, ensure it implements <code>log_writer_interface</code>. See Best Practices</li>
</ol>
<h2><a class="anchor" id="autotoc_md1568"></a>
Support Policy</h2>
<ul>
<li><b>v4.x series</b>: Full backward compatibility, deprecation warnings only</li>
<li><b>v5.0.0</b>: Legacy classes removed, builder API required</li>
<li><b>Migration support</b>: See <a href="../../examples/writer_builder_example.cpp">examples/writer_builder_example.cpp</a></li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md1570"></a>
Best Practices</h1>
<h2><a class="anchor" id="autotoc_md1571"></a>
1. Keep Leaf Writers Simple</h2>
<p>Leaf writers should only handle destination-specific I/O:</p>
<div class="fragment"><div class="line"><span class="comment">// Good: Focused on one thing</span></div>
<div class="line"><span class="keyword">class </span>kafka_writer : <span class="keyword">public</span> thread_safe_writer {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    common::VoidResult write_entry_impl(<span class="keyword">const</span> log_entry&amp; entry)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> kafka_client_.send(topic_, entry.formatted_message());</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Bad: Too many responsibilities</span></div>
<div class="line"><span class="keyword">class </span>kafka_writer : <span class="keyword">public</span> thread_safe_writer {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    common::VoidResult write_entry_impl(<span class="keyword">const</span> log_entry&amp; entry)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (entry.level() &lt; min_level_) <span class="keywordflow">return</span> {};  <span class="comment">// Should be filtered_writer</span></div>
<div class="line">        <span class="keyword">auto</span> json = to_json(entry);                  <span class="comment">// Should be formatted_writer</span></div>
<div class="line">        buffer_.push(json);                          <span class="comment">// Should be buffered_writer</span></div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1572"></a>
2. Use Category Tags</h2>
<p>Mark your writers with appropriate category tags:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>my_sync_writer : <span class="keyword">public</span> thread_safe_writer, <span class="keyword">public</span> sync_writer_tag { ... };</div>
<div class="line"><span class="keyword">class </span>my_async_writer : <span class="keyword">public</span> queued_writer_base, <span class="keyword">public</span> async_writer_tag { ... };</div>
<div class="line"><span class="keyword">class </span>my_decorator : <span class="keyword">public</span> decorator_writer_base, <span class="keyword">public</span> decorator_writer_tag { ... };</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1573"></a>
3. Handle Errors Gracefully</h2>
<p>Decorators should propagate errors from wrapped writers:</p>
<div class="fragment"><div class="line">common::VoidResult write(<span class="keyword">const</span> log_entry&amp; entry)<span class="keyword"> override </span>{</div>
<div class="line">    <span class="comment">// Do pre-processing</span></div>
<div class="line">    <span class="keyword">auto</span> result = wrapped().write(entry);</div>
<div class="line">    <span class="keywordflow">if</span> (result.is_err()) {</div>
<div class="line">        <span class="keywordflow">return</span> result;  <span class="comment">// Propagate error</span></div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Do post-processing</span></div>
<div class="line">    <span class="keywordflow">return</span> {};</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1574"></a>
4. Ensure Thread Safety</h2>
<p>If your decorator maintains state, protect it:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>stateful_decorator : <span class="keyword">public</span> decorator_writer_base {</div>
<div class="line">    common::VoidResult write(<span class="keyword">const</span> log_entry&amp; entry)<span class="keyword"> override </span>{</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">        <span class="comment">// Access mutable state safely</span></div>
<div class="line">        <span class="keywordflow">return</span> wrapped().write(entry);</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::mutex mutex_;</div>
<div class="line">    <span class="comment">// mutable state...</span></div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md1576"></a>
Troubleshooting</h1>
<h2><a class="anchor" id="autotoc_md1577"></a>
Common Issues</h2>
<h3><a class="anchor" id="autotoc_md1578"></a>
"Writer not receiving entries"</h3>
<p><b>Symptom</b>: Log entries not appearing in output file or console.</p>
<p><b>Possible Causes</b>:</p>
<ol type="1">
<li><b>Decorator order is wrong</b> - Filters should be innermost:</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// Wrong: Filter after buffer means filtered entries still buffered</span></div>
<div class="line"><span class="keyword">auto</span> wrong = std::make_unique&lt;filtered_writer&gt;(</div>
<div class="line">    std::make_unique&lt;buffered_writer&gt;(...),</div>
<div class="line">    filter</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Right: Filter before buffer</span></div>
<div class="line"><span class="keyword">auto</span> right = std::make_unique&lt;buffered_writer&gt;(</div>
<div class="line">    std::make_unique&lt;filtered_writer&gt;(..., filter),</div>
<div class="line">    config</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Using builder (automatic correct order):</span></div>
<div class="line"><span class="keyword">auto</span> correct = writer_builder()</div>
<div class="line">    .file(<span class="stringliteral">&quot;app.log&quot;</span>)</div>
<div class="line">    .filtered(filter)  <span class="comment">// Applied first</span></div>
<div class="line">    .buffered(100)     <span class="comment">// Applied second</span></div>
<div class="line">    .build();</div>
</div><!-- fragment --><ol type="1">
<li><b>Writer not added to logger</b>:</li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">auto</span> writer = writer_builder().file(<span class="stringliteral">&quot;app.log&quot;</span>).build();</div>
<div class="line"><span class="comment">// Must add to logger!</span></div>
<div class="line">logger.add_writer(<span class="stringliteral">&quot;main&quot;</span>, std::move(writer));</div>
</div><!-- fragment --><ol type="1">
<li><b>Async writer not started</b>:</li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">auto</span> writer = writer_builder().file(<span class="stringliteral">&quot;app.log&quot;</span>).async().build();</div>
<div class="line"><span class="comment">// Must start async writer!</span></div>
<div class="line"><span class="keywordflow">if</span> (<span class="keyword">auto</span>* async_w = <span class="keyword">dynamic_cast&lt;</span>async_writer*<span class="keyword">&gt;</span>(writer.get())) {</div>
<div class="line">    async_w-&gt;start();</div>
<div class="line">}</div>
<div class="line">logger.add_writer(<span class="stringliteral">&quot;main&quot;</span>, std::move(writer));</div>
</div><!-- fragment --><ol type="1">
<li><b>Filter is too restrictive</b>:</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// This filter blocks everything below ERROR level</span></div>
<div class="line"><span class="keyword">auto</span> filter = std::make_unique&lt;level_filter&gt;(log_level::error);</div>
<div class="line"><span class="keyword">auto</span> writer = writer_builder()</div>
<div class="line">    .console()</div>
<div class="line">    .filtered(std::move(filter))</div>
<div class="line">    .build();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// INFO and DEBUG messages won&#39;t appear!</span></div>
<div class="line">logger.log(log_level::info, <span class="stringliteral">&quot;This won&#39;t show&quot;</span>);  <span class="comment">// Filtered out</span></div>
<div class="line">logger.log(log_level::error, <span class="stringliteral">&quot;This will show&quot;</span>);  <span class="comment">// Passes filter</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1579"></a>
"Entries not being formatted"</h3>
<p><b>Symptom</b>: Log entries appear in plain text instead of JSON/custom format.</p>
<p><b>Possible Causes</b>:</p>
<ol type="1">
<li><b>Formatter applied in wrong order</b>:</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// Wrong: Formatting lost because it&#39;s wrapped by buffer</span></div>
<div class="line"><span class="keyword">auto</span> wrong = std::make_unique&lt;buffered_writer&gt;(</div>
<div class="line">    std::make_unique&lt;formatted_writer&gt;(...),</div>
<div class="line">    config</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Right: Format just before output</span></div>
<div class="line"><span class="keyword">auto</span> right = std::make_unique&lt;formatted_writer&gt;(</div>
<div class="line">    std::make_unique&lt;buffered_writer&gt;(..., config),</div>
<div class="line">    formatter</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Using builder (handles order automatically):</span></div>
<div class="line"><span class="keyword">auto</span> correct = writer_builder()</div>
<div class="line">    .file(<span class="stringliteral">&quot;app.json&quot;</span>)</div>
<div class="line">    .buffered(100)</div>
<div class="line">    .formatted(std::make_unique&lt;json_formatter&gt;())</div>
<div class="line">    .build();</div>
</div><!-- fragment --><ol type="1">
<li><b>Formatter not provided</b>:</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// Missing formatter - will use default plain text</span></div>
<div class="line"><span class="keyword">auto</span> writer = writer_builder().file(<span class="stringliteral">&quot;app.json&quot;</span>).build();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add formatter for JSON output</span></div>
<div class="line"><span class="keyword">auto</span> writer = writer_builder()</div>
<div class="line">    .file(<span class="stringliteral">&quot;app.json&quot;</span>)</div>
<div class="line">    .formatted(std::make_unique&lt;json_formatter&gt;())</div>
<div class="line">    .build();</div>
</div><!-- fragment --><ol type="1">
<li><b>Incompatible formatter for writer type</b>:</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// Some formatters may not support all entry types</span></div>
<div class="line"><span class="comment">// Check formatter documentation for compatibility</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1580"></a>
"Flush not working"</h3>
<p><b>Symptom</b>: Logs not appearing immediately, delayed until program exit.</p>
<p><b>Possible Causes</b>:</p>
<ol type="1">
<li><b>Flushing wrong writer</b>:</li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">auto</span> inner = std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> buffered = std::make_unique&lt;buffered_writer&gt;(std::move(inner), config);</div>
<div class="line"><span class="keyword">auto</span> outermost = std::make_unique&lt;formatted_writer&gt;(std::move(buffered), formatter);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wrong: Flushing reference to moved writer (undefined behavior)</span></div>
<div class="line"><span class="comment">// inner-&gt;flush();  // Don&#39;t do this!</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Right: Flush the outermost decorator</span></div>
<div class="line">outermost-&gt;flush();</div>
</div><!-- fragment --><ol type="1">
<li><b>Not calling flush() at all</b>:</li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">auto</span> writer = writer_builder().file(<span class="stringliteral">&quot;app.log&quot;</span>).buffered(100).build();</div>
<div class="line">logger.add_writer(<span class="stringliteral">&quot;main&quot;</span>, std::move(writer));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Logs buffered but not flushed</span></div>
<div class="line">logger.log(log_level::info, <span class="stringliteral">&quot;Message&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Must flush before exit!</span></div>
<div class="line">logger.flush();  <span class="comment">// This flushes all writers</span></div>
</div><!-- fragment --><ol type="1">
<li><b>Async writer not stopped properly</b>:</li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">auto</span> writer = writer_builder().file(<span class="stringliteral">&quot;app.log&quot;</span>).async().build();</div>
<div class="line"><span class="keywordflow">if</span> (<span class="keyword">auto</span>* async_w = <span class="keyword">dynamic_cast&lt;</span>async_writer*<span class="keyword">&gt;</span>(writer.get())) {</div>
<div class="line">    async_w-&gt;start();</div>
<div class="line">}</div>
<div class="line">logger.add_writer(<span class="stringliteral">&quot;main&quot;</span>, std::move(writer));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Before program exit:</span></div>
<div class="line">logger.flush();  <span class="comment">// Flush buffered entries</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get async writer reference and stop it</span></div>
<div class="line"><span class="keyword">auto</span>&amp; writer_ref = logger.get_writer(<span class="stringliteral">&quot;main&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (<span class="keyword">auto</span>* async_w = <span class="keyword">dynamic_cast&lt;</span>async_writer*<span class="keyword">&gt;</span>(&amp;writer_ref)) {</div>
<div class="line">    async_w-&gt;stop();  <span class="comment">// Processes remaining queue</span></div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li><b>Buffer size too large</b>:</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// Very large buffer - may never fill up in short-running programs</span></div>
<div class="line"><span class="keyword">auto</span> writer = writer_builder()</div>
<div class="line">    .file(<span class="stringliteral">&quot;app.log&quot;</span>)</div>
<div class="line">    .buffered(10000)  <span class="comment">// Too large for a few log messages</span></div>
<div class="line">    .build();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Solution: Use smaller buffer or explicit flush</span></div>
<div class="line"><span class="keyword">auto</span> writer = writer_builder()</div>
<div class="line">    .file(<span class="stringliteral">&quot;app.log&quot;</span>)</div>
<div class="line">    .buffered(100)  <span class="comment">// More reasonable</span></div>
<div class="line">    .build();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1581"></a>
"Compilation errors with custom writers"</h3>
<p><b>Symptom</b>: Custom writer doesn't compile after migration to decorator pattern.</p>
<p><b>Possible Causes</b>:</p>
<ol type="1">
<li><b>Missing interface methods</b>:</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// Error: abstract class cannot be instantiated</span></div>
<div class="line"><span class="keyword">class </span>my_writer : <span class="keyword">public</span> thread_safe_writer {</div>
<div class="line">    <span class="comment">// Missing required methods!</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Solution: Implement all required methods</span></div>
<div class="line"><span class="keyword">class </span>my_writer : <span class="keyword">public</span> thread_safe_writer {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::string get_name()<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;my_writer&quot;</span>; }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    common::VoidResult write_entry_impl(<span class="keyword">const</span> log_entry&amp; entry)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Implementation</span></div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    common::VoidResult flush_impl()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Implementation</span></div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><ol type="1">
<li><b>Wrong base class</b>:</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// Wrong: Using old base_writer class</span></div>
<div class="line"><span class="keyword">class </span>my_writer : <span class="keyword">public</span> base_writer { ... };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Right: Use thread_safe_writer or implement log_writer_interface</span></div>
<div class="line"><span class="keyword">class </span>my_writer : <span class="keyword">public</span> thread_safe_writer { ... };</div>
</div><!-- fragment --><ol type="1">
<li><b>Incorrect method signatures</b>:</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// Wrong: Missing const qualifier</span></div>
<div class="line">std::string get_name() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;my_writer&quot;</span>; }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Right: Match interface exactly</span></div>
<div class="line">std::string get_name()<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;my_writer&quot;</span>; }</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1582"></a>
"Performance regression after migration"</h3>
<p><b>Symptom</b>: Logging is slower after switching to decorator pattern.</p>
<p><b>Possible Causes</b>:</p>
<ol type="1">
<li><b>Too many decorator layers</b>:</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// Avoid excessive nesting</span></div>
<div class="line"><span class="keyword">auto</span> writer = writer_builder()</div>
<div class="line">    .file(<span class="stringliteral">&quot;app.log&quot;</span>)</div>
<div class="line">    .filtered(filter1)</div>
<div class="line">    .filtered(filter2)  <span class="comment">// Each filter adds overhead</span></div>
<div class="line">    .filtered(filter3)</div>
<div class="line">    .buffered(100)</div>
<div class="line">    .buffered(50)       <span class="comment">// Multiple buffers inefficient</span></div>
<div class="line">    .async()</div>
<div class="line">    .build();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Better: Use composite filter and single buffer</span></div>
<div class="line"><span class="keyword">auto</span> composite_filter = std::make_unique&lt;composite_filter&gt;(logic_type::AND);</div>
<div class="line">composite_filter-&gt;add_filter(std::move(filter1));</div>
<div class="line">composite_filter-&gt;add_filter(std::move(filter2));</div>
<div class="line">composite_filter-&gt;add_filter(std::move(filter3));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> writer = writer_builder()</div>
<div class="line">    .file(<span class="stringliteral">&quot;app.log&quot;</span>)</div>
<div class="line">    .filtered(std::move(composite_filter))</div>
<div class="line">    .buffered(100)</div>
<div class="line">    .async()</div>
<div class="line">    .build();</div>
</div><!-- fragment --><ol type="1">
<li><b>Wrong decorator order</b>:</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// Inefficient: Buffering before filtering</span></div>
<div class="line"><span class="keyword">auto</span> slow = writer_builder()</div>
<div class="line">    .file(<span class="stringliteral">&quot;app.log&quot;</span>)</div>
<div class="line">    .buffered(100)      <span class="comment">// Buffers everything</span></div>
<div class="line">    .filtered(filter)   <span class="comment">// Then filters (wasted buffer space)</span></div>
<div class="line">    .build();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Efficient: Filtering before buffering</span></div>
<div class="line"><span class="keyword">auto</span> fast = writer_builder()</div>
<div class="line">    .file(<span class="stringliteral">&quot;app.log&quot;</span>)</div>
<div class="line">    .filtered(filter)   <span class="comment">// Filter first</span></div>
<div class="line">    .buffered(100)      <span class="comment">// Only buffer passing entries</span></div>
<div class="line">    .build();</div>
</div><!-- fragment --><ol type="1">
<li><b>Async not used for high-throughput scenarios</b>:</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// Synchronous writing blocks caller</span></div>
<div class="line"><span class="keyword">auto</span> slow = writer_builder()</div>
<div class="line">    .file(<span class="stringliteral">&quot;app.log&quot;</span>)</div>
<div class="line">    .buffered(100)</div>
<div class="line">    .build();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Async writing is non-blocking</span></div>
<div class="line"><span class="keyword">auto</span> fast = writer_builder()</div>
<div class="line">    .file(<span class="stringliteral">&quot;app.log&quot;</span>)</div>
<div class="line">    .buffered(100)</div>
<div class="line">    .async(20000)</div>
<div class="line">    .build();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1583"></a>
Migration Checklist</h2>
<p>Before starting migration:</p><ul>
<li>[ ] Read this entire migration guide</li>
<li>[ ] Review <a href="../../examples/decorator_usage.cpp">decorator_usage.cpp</a> examples</li>
<li>[ ] Identify all existing writer usage in codebase</li>
</ul>
<p>During migration:</p><ul>
<li>[ ] Identify cross-cutting concerns in existing writers</li>
<li>[ ] Separate destination logic from filtering/buffering/formatting</li>
<li>[ ] Create simple leaf writers inheriting from <code>thread_safe_writer</code></li>
<li>[ ] Replace manual nesting with <code>writer_builder()</code></li>
<li>[ ] Use built-in decorators for common functionality</li>
<li>[ ] Create custom decorators only for unique cross-cutting needs</li>
<li>[ ] Start async writers with <code>.start()</code> where applicable</li>
</ul>
<p>After migration:</p><ul>
<li>[ ] Update tests to verify decorator composition</li>
<li>[ ] Test with actual log messages (info, warning, error levels)</li>
<li>[ ] Verify flush() works correctly before program exit</li>
<li>[ ] Benchmark to ensure no performance regression</li>
<li>[ ] Update documentation for your project</li>
<li>[ ] Remove deprecated code once validated</li>
</ul>
<h2><a class="anchor" id="autotoc_md1584"></a>
Getting Help</h2>
<p>If you encounter issues not covered in this guide:</p>
<ol type="1">
<li>Check <a href="../../examples/decorator_usage.cpp">examples/decorator_usage.cpp</a> for comprehensive examples</li>
<li>Review <a href="../../examples/writer_builder_example.cpp">writer_builder_example.cpp</a> for builder API patterns</li>
<li>See <a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2guides_2BEST__PRACTICES.html">Best Practices</a> for general guidance</li>
<li>Check <a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2guides_2FAQ.html">FAQ</a> for common questions</li>
<li>File an issue on <a href="https://github.com/kcenon/logger_system/issues">GitHub</a> with:<ul>
<li>Current code (manual nesting)</li>
<li>Expected behavior</li>
<li>Error messages or compilation errors</li>
<li>Platform and compiler version</li>
</ul>
</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md1586"></a>
Related Documentation</h1>
<ul>
<li><a href="../../examples/writer_builder_example.cpp">writer_builder Example</a> - Complete usage examples</li>
<li><a href="../API_REFERENCE.md#writers">API Reference - Writers</a></li>
<li><a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2ARCHITECTURE.html">Architecture Overview</a></li>
<li><a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2CHANGELOG.html">Changelog</a> - Version history and breaking changes</li>
<li><a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2guides_2BEST__PRACTICES.html">Best Practices</a></li>
</ul>
<hr  />
<p><em>Part of Logger System v4.1+ documentation</em> <em>Last updated: 2026-02-01 for v4.1.0 deprecation timeline</em> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Feb 9 2026 02:11:09 for Logger System by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
