<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Logger System: CRITICAL_LOG_PREVENTION</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Logger System<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-performance C++20 thread-safe logging system with asynchronous capabilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__2home_2runner_2work_2logger__system_2logger__system_2docs_2advanced_2CRITICAL__LOG__PREVENTION.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">CRITICAL_LOG_PREVENTION</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><blockquote class="doxtable">
<p>&zwj;<b>Language:</b> <b>English</b> | <a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2advanced_2CRITICAL__LOG__PREVENTION_8kr.html">한국어</a> </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md307"></a>
Table of Contents</h2>
<ul>
<li>Overview<ul>
<li>Problem</li>
<li>Solution</li>
</ul>
</li>
<li>Architecture</li>
<li>Class Structure<ul>
<li>1. `critical_writer`<ul>
<li>Key Features:</li>
<li>Configuration:</li>
<li>Usage Example:</li>
</ul>
</li>
<li>2. `hybrid_writer`<ul>
<li>Features:</li>
<li>Usage Example:</li>
</ul>
</li>
</ul>
</li>
<li>How It Works<ul>
<li>1. Level-Based Routing</li>
<li>2. Critical Write Flow<ul>
<li>Step-by-Step Explanation:</li>
</ul>
</li>
<li>3. Write-Ahead Logging (WAL)<ul>
<li>WAL Format:</li>
<li>WAL Usage:</li>
</ul>
</li>
<li>4. Signal Handler<ul>
<li>Handled Signals:</li>
<li>Signal Handler Implementation:</li>
<li>Important Notes:</li>
</ul>
</li>
<li>5. File Descriptor Sync<ul>
<li>Buffer Layers:</li>
<li>Implementation:</li>
</ul>
</li>
</ul>
</li>
<li>Performance Impact<ul>
<li>1. Critical Log Overhead</li>
<li>2. Normal Log Impact</li>
<li>3. Optimization Strategies<ul>
<li>Strategy 1: Disable `sync_on_critical`</li>
<li>Strategy 2: Disable `force_flush_on_error`</li>
<li>Strategy 3: Use Hybrid Writer</li>
</ul>
</li>
<li>4. Benchmark Results (Estimated)</li>
</ul>
</li>
<li>Production Recommendations<ul>
<li>1. Default Configuration (General Services)</li>
<li>2. High Reliability Configuration (Finance/Medical)</li>
<li>3. High Performance Configuration (Games/Real-time Systems)</li>
</ul>
</li>
<li>Testing &amp; Verification<ul>
<li>1. Critical Log Loss Test<ul>
<li>Verification Method:</li>
</ul>
</li>
<li>2. WAL Recovery Test</li>
<li>3. Performance Benchmark</li>
</ul>
</li>
<li>Troubleshooting<ul>
<li>Issue 1: WAL File Not Created</li>
<li>Issue 2: Signal Handler Not Working</li>
<li>Issue 3: Performance Degradation</li>
</ul>
</li>
<li>FAQ<ul>
<li>Q1: Should I wrap all logs with critical_writer?</li>
<li>Q2: When should I use WAL?</li>
<li>Q3: fsync() overhead is too high.</li>
<li>Q4: What can I do in a signal handler?</li>
</ul>
</li>
<li>References</li>
<li>Version History</li>
<li>License</li>
</ul>
<h1><a class="anchor" id="autotoc_md308"></a>
Critical Log Loss Prevention Guide</h1>
<p><b>Version:</b> 0.1.1.0 <b>Author:</b> kcenon <b>Date:</b> 2025-01-17</p>
<h2><a class="anchor" id="autotoc_md309"></a>
Overview</h2>
<p>This document describes mechanisms to prevent critical log message loss in logger_system.</p>
<h3><a class="anchor" id="autotoc_md310"></a>
Problem</h3>
<p>Issues that can occur when using asynchronous loggers:</p>
<ol type="1">
<li><b>Queue Message Loss</b>: Messages in async queue are lost during process crashes</li>
<li><b>Unflushed Buffers</b>: Data in OS buffers not written to disk during abnormal termination</li>
<li><b>Insufficient Signal Handling</b>: Termination without handling SIGTERM, SIGSEGV, etc.</li>
<li><b>I/O Buffering</b>: Delayed writes due to filesystem buffering</li>
</ol>
<h3><a class="anchor" id="autotoc_md311"></a>
Solution</h3>
<p>This solution provides the following mechanisms:</p>
<ol type="1">
<li><b>Synchronous Critical Writer</b>: Critical logs bypass queue and write immediately</li>
<li><b>Immediate Flush</b>: Automatic flush at critical levels</li>
<li><b>Signal Handlers</b>: Handle SIGTERM, SIGINT, SIGSEGV, SIGABRT</li>
<li><b>Write-Ahead Logging (WAL)</b>: Write to separate WAL file first</li>
<li><b>File Descriptor Sync</b>: Force flush to OS buffers via <code>fsync()</code> call</li>
</ol>
<hr  />
<h2><a class="anchor" id="autotoc_md313"></a>
Architecture</h2>
<div class="fragment"><div class="line">┌─────────────────────────────────────────────────────────────────┐</div>
<div class="line">│                      Application Code                           │</div>
<div class="line">└────────────────────────────┬────────────────────────────────────┘</div>
<div class="line">                             │</div>
<div class="line">                             ▼</div>
<div class="line">┌─────────────────────────────────────────────────────────────────┐</div>
<div class="line">│                       Logger Instance                           │</div>
<div class="line">│                                                                 │</div>
<div class="line">│  • log(level, message)                                          │</div>
<div class="line">│  • Level check (trace/debug/info/warn/error/critical/fatal)    │</div>
<div class="line">└────────────────────────────┬────────────────────────────────────┘</div>
<div class="line">                             │</div>
<div class="line">                ┌────────────┴────────────┐</div>
<div class="line">                │                         │</div>
<div class="line">                ▼                         ▼</div>
<div class="line">    ┌──────────────────┐      ┌──────────────────┐</div>
<div class="line">    │  Normal Logs     │      │  Critical Logs   │</div>
<div class="line">    │  (info/debug)    │      │  (error/critical)│</div>
<div class="line">    └────────┬─────────┘      └────────┬─────────┘</div>
<div class="line">             │                         │</div>
<div class="line">             ▼                         ▼</div>
<div class="line">    ┌──────────────────┐      ┌──────────────────┐</div>
<div class="line">    │  Async Queue     │      │  Bypass Queue    │</div>
<div class="line">    │  (10k messages)  │      │  (Direct Write)  │</div>
<div class="line">    └────────┬─────────┘      └────────┬─────────┘</div>
<div class="line">             │                         │</div>
<div class="line">             │                         ▼</div>
<div class="line">             │                ┌──────────────────┐</div>
<div class="line">             │                │  Write to WAL    │</div>
<div class="line">             │                │  (.critical.wal) │</div>
<div class="line">             │                └────────┬─────────┘</div>
<div class="line">             │                         │</div>
<div class="line">             │                         ▼</div>
<div class="line">             │                ┌──────────────────┐</div>
<div class="line">             │                │  Wrapped Writer  │</div>
<div class="line">             │                │  (file/console)  │</div>
<div class="line">             │                └────────┬─────────┘</div>
<div class="line">             │                         │</div>
<div class="line">             └────────────────┬────────┘</div>
<div class="line">                              │</div>
<div class="line">                              ▼</div>
<div class="line">                     ┌──────────────────┐</div>
<div class="line">                     │  Immediate Flush │</div>
<div class="line">                     │  (critical only) │</div>
<div class="line">                     └────────┬─────────┘</div>
<div class="line">                              │</div>
<div class="line">                              ▼</div>
<div class="line">                     ┌──────────────────┐</div>
<div class="line">                     │  fsync() / sync  │</div>
<div class="line">                     │  (OS buffer)     │</div>
<div class="line">                     └────────┬─────────┘</div>
<div class="line">                              │</div>
<div class="line">                              ▼</div>
<div class="line">                         ┌─────────┐</div>
<div class="line">                         │  Disk   │</div>
<div class="line">                         └─────────┘</div>
<div class="line"> </div>
<div class="line">┌─────────────────────────────────────────────────────────────────┐</div>
<div class="line">│                     Signal Handler Layer                         │</div>
<div class="line">│                                                                 │</div>
<div class="line">│  SIGTERM → Emergency Flush → Exit                               │</div>
<div class="line">│  SIGINT  → Emergency Flush → Exit                               │</div>
<div class="line">│  SIGSEGV → Emergency Flush → Re-raise signal                    │</div>
<div class="line">│  SIGABRT → Emergency Flush → Re-raise signal                    │</div>
<div class="line">└─────────────────────────────────────────────────────────────────┘</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md315"></a>
Class Structure</h2>
<h3><a class="anchor" id="autotoc_md316"></a>
1. &lt;tt&gt;critical_writer&lt;/tt&gt;</h3>
<p>A writer wrapper that processes critical logs synchronously.</p>
<h4><a class="anchor" id="autotoc_md317"></a>
Key Features:</h4>
<ul>
<li><b>Level-based Routing</b>: Choose sync/async based on log level</li>
<li><b>Immediate Flush</b>: Flush critical/fatal messages immediately</li>
<li><b>WAL Support</b>: Optional Write-Ahead Logging</li>
<li><b>Signal Handling</b>: Automatic flush on abnormal termination</li>
<li><b>File Sync</b>: Reflect to disk including OS buffers via <code>fsync()</code> call</li>
</ul>
<h4><a class="anchor" id="autotoc_md318"></a>
Configuration:</h4>
<div class="fragment"><div class="line"><span class="keyword">struct </span>critical_writer_config {</div>
<div class="line">    <span class="comment">// Immediate flush for critical/fatal messages (default: true)</span></div>
<div class="line">    <span class="keywordtype">bool</span> force_flush_on_critical = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Immediate flush for error messages too (default: false)</span></div>
<div class="line">    <span class="keywordtype">bool</span> force_flush_on_error = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Enable signal handlers (default: true)</span></div>
<div class="line">    <span class="keywordtype">bool</span> enable_signal_handlers = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Enable Write-Ahead Logging (default: false)</span></div>
<div class="line">    <span class="keywordtype">bool</span> write_ahead_log = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// WAL file path</span></div>
<div class="line">    std::string wal_path = <span class="stringliteral">&quot;logs/.wal&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Call fsync after critical write (default: true)</span></div>
<div class="line">    <span class="keywordtype">bool</span> sync_on_critical = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Critical write timeout in ms (0 = unlimited)</span></div>
<div class="line">    uint32_t critical_write_timeout_ms = 5000;</div>
<div class="line">};</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md319"></a>
Usage Example:</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/critical_writer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Default configuration</span></div>
<div class="line"><span class="keyword">auto</span> critical = std::make_unique&lt;critical_writer&gt;(</div>
<div class="line">    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>)</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom configuration</span></div>
<div class="line"><span class="keyword">auto</span> critical = std::make_unique&lt;critical_writer&gt;(</div>
<div class="line">    std::make_unique&lt;rotating_file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>, 10_MB, 5),</div>
<div class="line">    critical_writer_config{</div>
<div class="line">        .force_flush_on_critical = <span class="keyword">true</span>,</div>
<div class="line">        .force_flush_on_error = <span class="keyword">true</span>,</div>
<div class="line">        .enable_signal_handlers = <span class="keyword">true</span>,</div>
<div class="line">        .write_ahead_log = <span class="keyword">true</span>,</div>
<div class="line">        .wal_path = <span class="stringliteral">&quot;logs/.app.wal&quot;</span>,</div>
<div class="line">        .sync_on_critical = <span class="keyword">true</span></div>
<div class="line">    }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">logger.add_writer(std::move(critical));</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md320"></a>
2. &lt;tt&gt;hybrid_writer&lt;/tt&gt;</h3>
<p>A hybrid writer that processes normal logs asynchronously and critical logs synchronously.</p>
<h4><a class="anchor" id="autotoc_md321"></a>
Features:</h4>
<ul>
<li><b>Performance + Safety</b>: High throughput with async, immediate flush when critical</li>
<li><b>Automatic Routing</b>: Automatically select path based on log level</li>
<li><b>Simple Configuration</b>: Integrates critical_writer + async_writer into one</li>
</ul>
<h4><a class="anchor" id="autotoc_md322"></a>
Usage Example:</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/critical_writer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> hybrid = std::make_unique&lt;hybrid_writer&gt;(</div>
<div class="line">    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>),</div>
<div class="line">    critical_writer_config{</div>
<div class="line">        .force_flush_on_critical = <span class="keyword">true</span>,</div>
<div class="line">        .enable_signal_handlers = <span class="keyword">true</span></div>
<div class="line">    },</div>
<div class="line">    10000  <span class="comment">// Async queue size</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">logger.add_writer(std::move(hybrid));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now automatically handled based on log level:</span></div>
<div class="line">logger.log(log_level::info, <span class="stringliteral">&quot;Fast async&quot;</span>);       <span class="comment">// → Async queue</span></div>
<div class="line">logger.log(log_level::critical, <span class="stringliteral">&quot;Immediate&quot;</span>);    <span class="comment">// → Bypass queue + flush</span></div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md324"></a>
How It Works</h2>
<h3><a class="anchor" id="autotoc_md325"></a>
1. Level-Based Routing</h3>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> critical_writer::is_critical_level(log_level level)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="comment">// Critical and fatal always require immediate flush</span></div>
<div class="line">    <span class="keywordflow">if</span> (level &gt;= log_level::critical) {</div>
<div class="line">        <span class="keywordflow">return</span> config_.force_flush_on_critical;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Error level if configured</span></div>
<div class="line">    <span class="keywordflow">if</span> (level == log_level::error) {</div>
<div class="line">        <span class="keywordflow">return</span> config_.force_flush_on_error;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Log level checks:</p><ul>
<li><code>log_level::critical</code> (5): Always process immediately</li>
<li><code>log_level::fatal</code> (5): Always process immediately</li>
<li><code>log_level::error</code> (4): Process immediately if configured</li>
<li><code>log_level::warn</code> (3) and below: Normal path (async possible)</li>
</ul>
<h3><a class="anchor" id="autotoc_md326"></a>
2. Critical Write Flow</h3>
<div class="fragment"><div class="line">common::VoidResult critical_writer::write(...) {</div>
<div class="line">    <span class="keywordflow">if</span> (is_critical_level(level)) {</div>
<div class="line">        <span class="comment">// 1. Acquire exclusive lock</span></div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(critical_mutex_);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// 2. Write to WAL first (if enabled)</span></div>
<div class="line">        <span class="keywordflow">if</span> (wal_stream_) {</div>
<div class="line">            write_to_wal(...);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// 3. Write to wrapped writer</span></div>
<div class="line">        <span class="keyword">auto</span> result = wrapped_writer_-&gt;write(...);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// 4. Immediate flush</span></div>
<div class="line">        wrapped_writer_-&gt;flush();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// 5. Sync file descriptor (if configured)</span></div>
<div class="line">        <span class="keywordflow">if</span> (config_.sync_on_critical) {</div>
<div class="line">            sync_file_descriptor();  <span class="comment">// fsync()</span></div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> result;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Non-critical: delegate normally</span></div>
<div class="line">    <span class="keywordflow">return</span> wrapped_writer_-&gt;write(...);</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md327"></a>
Step-by-Step Explanation:</h4>
<ol type="1">
<li><b>Exclusive Lock</b>: Guarantee ordering between critical writes</li>
<li><b>WAL Write</b>: Write to separate WAL file first (for recovery)</li>
<li><b>Main Write</b>: Write to actual log file</li>
<li><b>Immediate Flush</b>: Empty buffer (<code>fflush()</code>)</li>
<li><b>File Sync</b>: Reflect to disk including OS buffers (<code>fsync()</code>)</li>
</ol>
<h3><a class="anchor" id="autotoc_md328"></a>
3. Write-Ahead Logging (WAL)</h3>
<p>WAL is an additional safety measure for crash recovery.</p>
<h4><a class="anchor" id="autotoc_md329"></a>
WAL Format:</h4>
<div class="fragment"><div class="line">[2025-01-17 14:30:45.123] [CRITICAL] [main.cpp:42:handle_error] Out of memory</div>
<div class="line">[2025-01-17 14:30:45.456] [FATAL] [main.cpp:50:main] Terminating</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md330"></a>
WAL Usage:</h4>
<div class="fragment"><div class="line"><span class="comment">// Enable WAL</span></div>
<div class="line">critical_writer_config config;</div>
<div class="line">config.write_ahead_log = <span class="keyword">true</span>;</div>
<div class="line">config.wal_path = <span class="stringliteral">&quot;logs/.critical.wal&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> critical = std::make_unique&lt;critical_writer&gt;(</div>
<div class="line">    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>),</div>
<div class="line">    config</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Crash recovery (separate tool)</span></div>
<div class="line"><span class="comment">// $ cat logs/.critical.wal | grep CRITICAL</span></div>
<div class="line"><span class="comment">// → Can check critical logs just before crash</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md331"></a>
4. Signal Handler</h3>
<p>Preserves logs even during abnormal termination.</p>
<h4><a class="anchor" id="autotoc_md332"></a>
Handled Signals:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Signal   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Action    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>SIGTERM</code>   </td><td class="markdownTableBodyNone">Normal termination request   </td><td class="markdownTableBodyNone">Emergency flush → Exit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>SIGINT</code>   </td><td class="markdownTableBodyNone">Ctrl+C interrupt   </td><td class="markdownTableBodyNone">Emergency flush → Exit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>SIGSEGV</code>   </td><td class="markdownTableBodyNone">Segmentation fault   </td><td class="markdownTableBodyNone">Emergency flush → Re-raise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>SIGABRT</code>   </td><td class="markdownTableBodyNone">abort() call   </td><td class="markdownTableBodyNone">Emergency flush → Re-raise   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md333"></a>
Signal Handler Implementation:</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> critical_writer::signal_handler(<span class="keywordtype">int</span> signal) {</div>
<div class="line">    critical_writer* writer = instance_.load();</div>
<div class="line">    <span class="keywordflow">if</span> (!writer) <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 1. Output emergency message</span></div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;[critical_writer] Signal &quot;</span> &lt;&lt; signal</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; received, emergency flush\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Flush immediately (no memory allocation!)</span></div>
<div class="line">    <span class="keywordflow">if</span> (writer-&gt;wrapped_writer_) {</div>
<div class="line">        writer-&gt;wrapped_writer_-&gt;flush();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. WAL flush</span></div>
<div class="line">    <span class="keywordflow">if</span> (writer-&gt;wal_stream_) {</div>
<div class="line">        writer-&gt;wal_stream_-&gt;flush();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 4. Re-raise SIGSEGV/SIGABRT to original handler</span></div>
<div class="line">    <span class="keywordflow">if</span> (signal == SIGSEGV || signal == SIGABRT) {</div>
<div class="line">        writer-&gt;restore_signal_handlers();</div>
<div class="line">        std::raise(signal);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md334"></a>
Important Notes:</h4>
<ul>
<li><b>No memory allocation</b> inside signal handler</li>
<li><b>Use only signal-safe functions</b> (async-signal-safe)</li>
<li>Avoid complex logic, perform minimal flush only</li>
</ul>
<h3><a class="anchor" id="autotoc_md335"></a>
5. File Descriptor Sync</h3>
<p><code>fflush()</code> only empties C library buffers; OS kernel buffers remain. Must call <code>fsync()</code> to fully write to disk.</p>
<h4><a class="anchor" id="autotoc_md336"></a>
Buffer Layers:</h4>
<div class="fragment"><div class="line">Application</div>
<div class="line">    ↓ fprintf/write</div>
<div class="line">[C Library Buffer]  ← Emptied by fflush()</div>
<div class="line">    ↓</div>
<div class="line">[OS Kernel Buffer]  ← Emptied by fsync()</div>
<div class="line">    ↓</div>
<div class="line">[Disk Controller]</div>
<div class="line">    ↓</div>
<div class="line">[Physical Disk]</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md337"></a>
Implementation:</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> critical_writer::sync_file_descriptor() {</div>
<div class="line"><span class="preprocessor">#ifdef __unix__</span></div>
<div class="line">    ::fsync(STDOUT_FILENO);</div>
<div class="line">    ::fsync(STDERR_FILENO);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get file descriptor from wrapped writer and sync</span></div>
<div class="line">    <span class="comment">// (Actual implementation needs to query fd from wrapped writer)</span></div>
<div class="line"><span class="preprocessor">#elif defined(_WIN32)</span></div>
<div class="line">    _commit(fd);  <span class="comment">// Windows equivalent</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md339"></a>
Performance Impact</h2>
<h3><a class="anchor" id="autotoc_md340"></a>
1. Critical Log Overhead</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation   </th><th class="markdownTableHeadNone">Estimated Time   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Mutex lock   </td><td class="markdownTableBodyNone">~20 ns   </td><td class="markdownTableBodyNone">Uncontended mutex    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">WAL write   </td><td class="markdownTableBodyNone">~50 μs   </td><td class="markdownTableBodyNone">Sequential write to SSD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Main write   </td><td class="markdownTableBodyNone">~50 μs   </td><td class="markdownTableBodyNone">Sequential write to SSD    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>fflush()</code>   </td><td class="markdownTableBodyNone">~100 μs   </td><td class="markdownTableBodyNone">C library buffer flush    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>fsync()</code>   </td><td class="markdownTableBodyNone"><b>1-10 ms</b>   </td><td class="markdownTableBodyNone">OS kernel → disk sync   </td></tr>
</table>
<p><b>Total Overhead</b>: <b>1-10 ms per critical log</b></p>
<h3><a class="anchor" id="autotoc_md341"></a>
2. Normal Log Impact</h3>
<ul>
<li><b>Normal/Debug/Info/Warn</b>: No impact (uses async queue)</li>
<li><b>Error</b> (if <code>force_flush_on_error=false</code>): No impact</li>
<li><b>Critical/Fatal</b>: Above overhead occurs</li>
</ul>
<h3><a class="anchor" id="autotoc_md342"></a>
3. Optimization Strategies</h3>
<h4><a class="anchor" id="autotoc_md343"></a>
Strategy 1: Disable &lt;tt&gt;sync_on_critical&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">critical_writer_config config;</div>
<div class="line">config.sync_on_critical = <span class="keyword">false</span>;  <span class="comment">// Skip fsync()</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Overhead: 1-10 ms → ~200 μs</span></div>
<div class="line"><span class="comment">// Risk: Medium (Remains in OS buffer, possible loss on kernel crash)</span></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md344"></a>
Strategy 2: Disable &lt;tt&gt;force_flush_on_error&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">config.force_flush_on_error = <span class="keyword">false</span>;  <span class="comment">// Process errors asynchronously</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Error level also uses async queue → No overhead</span></div>
<div class="line"><span class="comment">// Only critical/fatal processed immediately</span></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md345"></a>
Strategy 3: Use Hybrid Writer</h4>
<div class="fragment"><div class="line"><span class="keyword">auto</span> hybrid = std::make_unique&lt;hybrid_writer&gt;(</div>
<div class="line">    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>),</div>
<div class="line">    config,</div>
<div class="line">    50000  <span class="comment">// Large async queue</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Normal logs: Async (fast)</span></div>
<div class="line"><span class="comment">// Critical logs: Sync (safe)</span></div>
<div class="line"><span class="comment">// Average performance impact: &lt; 1%</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md346"></a>
4. Benchmark Results (Estimated)</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Scenario   </th><th class="markdownTableHeadNone">Throughput   </th><th class="markdownTableHeadNone">P99 Latency    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Async only (baseline)   </td><td class="markdownTableBodyNone">1,000,000 msg/s   </td><td class="markdownTableBodyNone">50 μs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Hybrid (1% critical)   </td><td class="markdownTableBodyNone">990,000 msg/s   </td><td class="markdownTableBodyNone">10 ms    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">All critical (worst case)   </td><td class="markdownTableBodyNone">100 msg/s   </td><td class="markdownTableBodyNone">10 ms   </td></tr>
</table>
<hr  />
<h2><a class="anchor" id="autotoc_md348"></a>
Production Recommendations</h2>
<h3><a class="anchor" id="autotoc_md349"></a>
1. Default Configuration (General Services)</h3>
<div class="fragment"><div class="line"><span class="keyword">auto</span> hybrid = std::make_unique&lt;hybrid_writer&gt;(</div>
<div class="line">    std::make_unique&lt;rotating_file_writer&gt;(</div>
<div class="line">        <span class="stringliteral">&quot;logs/production.log&quot;</span>,</div>
<div class="line">        100 * 1024 * 1024,  <span class="comment">// 100 MB</span></div>
<div class="line">        10                   <span class="comment">// 10 rotations</span></div>
<div class="line">    ),</div>
<div class="line">    critical_writer_config{</div>
<div class="line">        .force_flush_on_critical = <span class="keyword">true</span>,   <span class="comment">// ✅ Flush critical immediately</span></div>
<div class="line">        .force_flush_on_error = <span class="keyword">false</span>,     <span class="comment">// ❌ Errors async</span></div>
<div class="line">        .enable_signal_handlers = <span class="keyword">true</span>,    <span class="comment">// ✅ Signal handler</span></div>
<div class="line">        .write_ahead_log = <span class="keyword">false</span>,          <span class="comment">// ❌ WAL disabled (performance)</span></div>
<div class="line">        .sync_on_critical = <span class="keyword">true</span>           <span class="comment">// ✅ Call fsync()</span></div>
<div class="line">    },</div>
<div class="line">    50000  <span class="comment">// 50k async queue</span></div>
<div class="line">);</div>
</div><!-- fragment --><p><b>Characteristics</b>:</p><ul>
<li>Process only critical/fatal immediately</li>
<li>Maintain performance with async errors</li>
<li>Prepare for abnormal termination with signal handler</li>
<li>Prioritize performance without WAL</li>
</ul>
<h3><a class="anchor" id="autotoc_md350"></a>
2. High Reliability Configuration (Finance/Medical)</h3>
<div class="fragment"><div class="line"><span class="keyword">auto</span> hybrid = std::make_unique&lt;hybrid_writer&gt;(</div>
<div class="line">    std::make_unique&lt;rotating_file_writer&gt;(</div>
<div class="line">        <span class="stringliteral">&quot;logs/critical.log&quot;</span>,</div>
<div class="line">        50 * 1024 * 1024,   <span class="comment">// 50 MB</span></div>
<div class="line">        20                   <span class="comment">// 20 rotations (longer retention)</span></div>
<div class="line">    ),</div>
<div class="line">    critical_writer_config{</div>
<div class="line">        .force_flush_on_critical = <span class="keyword">true</span>,   <span class="comment">// ✅ Flush critical immediately</span></div>
<div class="line">        .force_flush_on_error = <span class="keyword">true</span>,      <span class="comment">// ✅ Flush errors too</span></div>
<div class="line">        .enable_signal_handlers = <span class="keyword">true</span>,    <span class="comment">// ✅ Signal handler</span></div>
<div class="line">        .write_ahead_log = <span class="keyword">true</span>,           <span class="comment">// ✅ Enable WAL</span></div>
<div class="line">        .wal_path = <span class="stringliteral">&quot;logs/.critical.wal&quot;</span>,</div>
<div class="line">        .sync_on_critical = <span class="keyword">true</span>,          <span class="comment">// ✅ Call fsync()</span></div>
<div class="line">        .critical_write_timeout_ms = 10000 <span class="comment">// 10 second timeout</span></div>
<div class="line">    },</div>
<div class="line">    10000  <span class="comment">// Smaller queue (faster drain)</span></div>
<div class="line">);</div>
</div><!-- fragment --><p><b>Characteristics</b>:</p><ul>
<li>Process all errors and above immediately</li>
<li>Crash recovery possible with WAL</li>
<li>Longer log retention period</li>
<li>Safety first</li>
</ul>
<h3><a class="anchor" id="autotoc_md351"></a>
3. High Performance Configuration (Games/Real-time Systems)</h3>
<div class="fragment"><div class="line"><span class="keyword">auto</span> hybrid = std::make_unique&lt;hybrid_writer&gt;(</div>
<div class="line">    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;logs/performance.log&quot;</span>),</div>
<div class="line">    critical_writer_config{</div>
<div class="line">        .force_flush_on_critical = <span class="keyword">true</span>,   <span class="comment">// ✅ Flush critical only</span></div>
<div class="line">        .force_flush_on_error = <span class="keyword">false</span>,     <span class="comment">// ❌ Errors async</span></div>
<div class="line">        .enable_signal_handlers = <span class="keyword">true</span>,    <span class="comment">// ✅ Signal handler</span></div>
<div class="line">        .write_ahead_log = <span class="keyword">false</span>,          <span class="comment">// ❌ WAL disabled</span></div>
<div class="line">        .sync_on_critical = <span class="keyword">false</span>          <span class="comment">// ❌ Skip fsync (fast!)</span></div>
<div class="line">    },</div>
<div class="line">    100000  <span class="comment">// 100k large queue</span></div>
<div class="line">);</div>
</div><!-- fragment --><p><b>Characteristics</b>:</p><ul>
<li>Process only critical immediately, skip fsync for speed</li>
<li>Errors fully async</li>
<li>Large queue for burst handling</li>
<li>Performance first</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md353"></a>
Testing &amp; Verification</h2>
<h3><a class="anchor" id="autotoc_md354"></a>
1. Critical Log Loss Test</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;csignal&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> test_signal_safety() {</div>
<div class="line">    logger log(<span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> critical = std::make_unique&lt;critical_writer&gt;(</div>
<div class="line">        std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;test_signal.log&quot;</span>),</div>
<div class="line">        critical_writer_config{</div>
<div class="line">            .enable_signal_handlers = <span class="keyword">true</span>,</div>
<div class="line">            .write_ahead_log = <span class="keyword">true</span>,</div>
<div class="line">            .wal_path = <span class="stringliteral">&quot;test_signal.wal&quot;</span></div>
<div class="line">        }</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    log.add_writer(std::move(critical));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Record critical log</span></div>
<div class="line">    log.log(log_level::critical, <span class="stringliteral">&quot;Before signal&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Force signal</span></div>
<div class="line">    std::raise(SIGTERM);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Verification: Check logs exist in test_signal.log and test_signal.wal</span></div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md355"></a>
Verification Method:</h4>
<div class="fragment"><div class="line"># 1. Run program</div>
<div class="line">$ ./test_signal_safety</div>
<div class="line"> </div>
<div class="line"># 2. Interrupt with Ctrl+C</div>
<div class="line">^C[critical_writer] Signal SIGINT received, emergency flush</div>
<div class="line">[critical_writer] Emergency flush completed</div>
<div class="line"> </div>
<div class="line"># 3. Check logs</div>
<div class="line">$ cat test_signal.log</div>
<div class="line">[2025-01-17 14:30:45] [CRITICAL] Before signal</div>
<div class="line"> </div>
<div class="line">$ cat test_signal.wal</div>
<div class="line">[2025-01-17 14:30:45.123] [CRITICAL] [test.cpp:10:test] Before signal</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md356"></a>
2. WAL Recovery Test</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> test_wal_recovery() {</div>
<div class="line">    <span class="comment">// Step 1: Write with WAL</span></div>
<div class="line">    {</div>
<div class="line">        logger log(<span class="keyword">false</span>);</div>
<div class="line">        <span class="keyword">auto</span> critical = std::make_unique&lt;critical_writer&gt;(</div>
<div class="line">            std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;main.log&quot;</span>),</div>
<div class="line">            critical_writer_config{</div>
<div class="line">                .write_ahead_log = <span class="keyword">true</span>,</div>
<div class="line">                .wal_path = <span class="stringliteral">&quot;main.wal&quot;</span></div>
<div class="line">            }</div>
<div class="line">        );</div>
<div class="line">        log.add_writer(std::move(critical));</div>
<div class="line"> </div>
<div class="line">        log.log(log_level::critical, <span class="stringliteral">&quot;Message 1&quot;</span>);</div>
<div class="line">        <span class="comment">// Simulate crash (don&#39;t call destructor)</span></div>
<div class="line">        std::exit(1);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 2: Recover from WAL</span></div>
<div class="line">    std::ifstream wal(<span class="stringliteral">&quot;main.wal&quot;</span>);</div>
<div class="line">    std::string line;</div>
<div class="line">    <span class="keywordflow">while</span> (std::getline(wal, line)) {</div>
<div class="line">        <span class="comment">// Parse and replay WAL entries</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Recovered: &quot;</span> &lt;&lt; line &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md357"></a>
3. Performance Benchmark</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> benchmark_critical_overhead() {</div>
<div class="line">    logger log(<span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Setup</span></div>
<div class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::now();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 1000 critical logs</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000; ++i) {</div>
<div class="line">        log.log(log_level::critical, <span class="stringliteral">&quot;Critical message &quot;</span> + std::to_string(i));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div>
<div class="line">    <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">        end - start</div>
<div class="line">    ).count();</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;1000 critical logs: &quot;</span> &lt;&lt; duration &lt;&lt; <span class="stringliteral">&quot; ms\n&quot;</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Average: &quot;</span> &lt;&lt; (duration / 1000.0) &lt;&lt; <span class="stringliteral">&quot; ms/log\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md359"></a>
Troubleshooting</h2>
<h3><a class="anchor" id="autotoc_md360"></a>
Issue 1: WAL File Not Created</h3>
<p><b>Symptom</b>: </p><div class="fragment"><div class="line">[critical_writer] Failed to open WAL: logs/.critical.wal</div>
</div><!-- fragment --><p><b>Cause</b>: Directory doesn't exist</p>
<p><b>Solution</b>: </p><div class="fragment"><div class="line"><span class="comment">// Create directory before WAL creation</span></div>
<div class="line"><span class="preprocessor">#include &lt;filesystem&gt;</span></div>
<div class="line">std::filesystem::create_directories(<span class="stringliteral">&quot;logs&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> critical = std::make_unique&lt;critical_writer&gt;(</div>
<div class="line">    std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;logs/app.log&quot;</span>),</div>
<div class="line">    critical_writer_config{</div>
<div class="line">        .write_ahead_log = <span class="keyword">true</span>,</div>
<div class="line">        .wal_path = <span class="stringliteral">&quot;logs/.critical.wal&quot;</span></div>
<div class="line">    }</div>
<div class="line">);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md361"></a>
Issue 2: Signal Handler Not Working</h3>
<p><b>Symptom</b>: Logs not flushed on Ctrl+C</p>
<p><b>Cause</b>: Signal handler disabled or conflicts</p>
<p><b>Solution</b>: </p><div class="fragment"><div class="line"><span class="comment">// 1. Confirm signal handler enabled</span></div>
<div class="line">critical_writer_config config;</div>
<div class="line">config.enable_signal_handlers = <span class="keyword">true</span>;  <span class="comment">// ✅</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 2. Check conflicts with other libraries</span></div>
<div class="line"><span class="comment">// (e.g., Google Test installs its own signal handler)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 3. Add explicit flush</span></div>
<div class="line">std::atexit([]() {</div>
<div class="line">    <span class="comment">// Explicit flush on exit</span></div>
<div class="line">    logger.flush();</div>
<div class="line">});</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md362"></a>
Issue 3: Performance Degradation</h3>
<p><b>Symptom</b>: Overall throughput decreases after using critical logs</p>
<p><b>Cause</b>: Processing all logs as critical</p>
<p><b>Solution</b>: </p><div class="fragment"><div class="line"><span class="comment">// ❌ Wrong usage</span></div>
<div class="line">logger.log(log_level::critical, <span class="stringliteral">&quot;User logged in&quot;</span>);  <span class="comment">// Normal event</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ✅ Correct usage</span></div>
<div class="line">logger.log(log_level::info, <span class="stringliteral">&quot;User logged in&quot;</span>);       <span class="comment">// Normal event</span></div>
<div class="line">logger.log(log_level::critical, <span class="stringliteral">&quot;Out of memory!&quot;</span>);   <span class="comment">// Real critical</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Or disable sync_on_critical</span></div>
<div class="line">config.sync_on_critical = <span class="keyword">false</span>;  <span class="comment">// Skip fsync → 10x faster</span></div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md364"></a>
FAQ</h2>
<h3><a class="anchor" id="autotoc_md365"></a>
Q1: Should I wrap all logs with critical_writer?</h3>
<p><b>A</b>: No. Use a mix of normal writer and critical_writer:</p>
<div class="fragment"><div class="line"><span class="comment">// Normal logs: async writer (performance)</span></div>
<div class="line">logger.add_writer(<span class="stringliteral">&quot;normal&quot;</span>,</div>
<div class="line">    std::make_unique&lt;async_writer&gt;(</div>
<div class="line">        std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>)</div>
<div class="line">    )</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Critical logs: critical writer (safety)</span></div>
<div class="line">logger.add_writer(<span class="stringliteral">&quot;critical&quot;</span>,</div>
<div class="line">    std::make_unique&lt;critical_writer&gt;(</div>
<div class="line">        std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;critical.log&quot;</span>)</div>
<div class="line">    )</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Or use hybrid_writer (recommended)</span></div>
<div class="line">logger.add_writer(<span class="stringliteral">&quot;hybrid&quot;</span>,</div>
<div class="line">    std::make_unique&lt;hybrid_writer&gt;(</div>
<div class="line">        std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;all.log&quot;</span>)</div>
<div class="line">    )</div>
<div class="line">);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md366"></a>
Q2: When should I use WAL?</h3>
<p><b>A</b>: Use WAL in these cases:</p>
<ul>
<li>✅ Financial transaction logs</li>
<li>✅ Medical record systems</li>
<li>✅ Security audit logs</li>
<li>❌ General application logs (overkill)</li>
<li>❌ High-performance game logs</li>
</ul>
<h3><a class="anchor" id="autotoc_md367"></a>
Q3: fsync() overhead is too high.</h3>
<p><b>A</b>: Consider these options:</p>
<ol type="1">
<li><b>Disable fsync</b>: <div class="fragment"><div class="line">config.sync_on_critical = <span class="keyword">false</span>;  <span class="comment">// 1-10ms → ~200μs</span></div>
</div><!-- fragment --></li>
<li><b>Batch fsync</b>: Collect multiple logs and sync at once (requires custom implementation)</li>
<li><b>XFS/ext4 optimization</b>: Filesystem mount options <div class="fragment"><div class="line"># /etc/fstab</div>
<div class="line">/dev/sda1 /logs xfs noatime,nodiratime 0 0</div>
</div><!-- fragment --></li>
</ol>
<h3><a class="anchor" id="autotoc_md368"></a>
Q4: What can I do in a signal handler?</h3>
<p><b>A</b>: <b>Very limited</b>. Only async-signal-safe functions:</p>
<p>✅ <b>Allowed</b>:</p><ul>
<li><code>write()</code> (low-level)</li>
<li><code>_exit()</code></li>
<li><code>signal()</code></li>
</ul>
<p>❌ <b>Not Allowed</b> (Undefined Behavior):</p><ul>
<li><code>malloc()</code> / <code>new</code></li>
<li><code>printf()</code> / <code>std::cout</code></li>
<li><code>std::lock_guard&lt;&gt;</code></li>
<li>Most C++ standard library</li>
</ul>
<p>This implementation performs minimal flush only.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md370"></a>
References</h2>
<ul>
<li><a href="https://man7.org/linux/man-pages/man7/signal-safety.7.html">POSIX Signal Safety</a></li>
<li><a href="https://man7.org/linux/man-pages/man2/fsync.2.html">fsync(2) - Linux Manual</a></li>
<li><a href="https://www.postgresql.org/docs/current/wal-intro.html">Write-Ahead Logging (PostgreSQL)</a></li>
<li><a href="https://github.com/gabime/spdlog#asynchronous-logging">spdlog Async Logging</a></li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md372"></a>
Version History</h2>
<ul>
<li><b>1.1.0</b> (2025-01-17): Initial implementation<ul>
<li>Add <code>critical_writer</code> class</li>
<li>Add <code>hybrid_writer</code> class</li>
<li>Implement signal handler</li>
<li>Support WAL</li>
<li>Integrate fsync()</li>
</ul>
</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md374"></a>
License</h2>
<p>BSD 3-Clause License Copyright (c) 2025, kcenon</p>
<hr  />
<p><em>Last Updated: 2025-10-20</em> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jan 19 2026 15:39:58 for Logger System by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
