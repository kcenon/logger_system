<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Logger System: Asynchronous Writer Implementations Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Logger System<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-performance C++20 thread-safe logging system with asynchronous capabilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__2home_2runner_2work_2logger__system_2logger__system_2docs_2advanced_2ASYNC__WRITERS.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Asynchronous Writer Implementations Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md185"></a> </p><blockquote class="doxtable">
<p>&zwj;<b>Language:</b> <b>English</b> | <a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2advanced_2ASYNC__WRITERS_8kr.html">한국어</a> </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md186"></a>
Overview</h1>
<p>The Logger System provides multiple asynchronous writer implementations, each optimized for different use cases. This guide helps you understand the differences and choose the right implementation for your needs.</p>
<p><b>Version:</b> 1.0.0 <b>Last Updated:</b> 2025-12-31</p>
<hr  />
<h1><a class="anchor" id="autotoc_md188"></a>
Table of Contents</h1>
<ul>
<li>Quick Decision Guide</li>
<li>Implementation Comparison</li>
<li>Detailed Descriptions<ul>
<li>async_writer</li>
<li>async_worker</li>
<li>high_performance_async_writer</li>
</ul>
</li>
<li>Performance Characteristics</li>
<li>Usage Examples</li>
<li>Best Practices</li>
<li>Migration Guide</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md190"></a>
Quick Decision Guide</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Use Case   </th><th class="markdownTableHeadNone">Recommended Implementation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>General async logging</b>   </td><td class="markdownTableBodyNone"><code>async_writer</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Simple async wrapper for any writer</b>   </td><td class="markdownTableBodyNone"><code>async_writer</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Maximum throughput (&gt;1M msg/sec)</b>   </td><td class="markdownTableBodyNone"><code>high_performance_async_writer</code> (internal)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Custom async task processing</b>   </td><td class="markdownTableBodyNone"><code>async_worker</code> (internal)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Production applications</b>   </td><td class="markdownTableBodyNone"><code>async_writer</code> with appropriate queue size   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md191"></a>
Decision Flowchart</h2>
<div class="fragment"><div class="line">Start</div>
<div class="line">  │</div>
<div class="line">  ├─ Need simple async wrapper? ──────────────► async_writer (Public API)</div>
<div class="line">  │</div>
<div class="line">  ├─ Need maximum throughput?</div>
<div class="line">  │   │</div>
<div class="line">  │   └─ Yes ──────────────────────────────────► high_performance_async_writer</div>
<div class="line">  │                                               (Internal, requires custom build)</div>
<div class="line">  │</div>
<div class="line">  └─ Building internal components? ────────────► async_worker (Internal API)</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md193"></a>
Implementation Comparison</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Aspect   </th><th class="markdownTableHeadNone"><code>async_writer</code>   </th><th class="markdownTableHeadNone"><code>async_worker</code>   </th><th class="markdownTableHeadNone"><code>high_performance_async_writer</code>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Location</b>   </td><td class="markdownTableBodyNone">Public API   </td><td class="markdownTableBodyNone">Internal   </td><td class="markdownTableBodyNone">Internal    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Header</b>   </td><td class="markdownTableBodyNone"><code>writers/async_writer.h</code>   </td><td class="markdownTableBodyNone"><code>src/impl/async/</code>   </td><td class="markdownTableBodyNone"><code>src/impl/async/</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Purpose</b>   </td><td class="markdownTableBodyNone">Wrap any writer   </td><td class="markdownTableBodyNone">Generic task worker   </td><td class="markdownTableBodyNone">Maximum throughput    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Queue Type</b>   </td><td class="markdownTableBodyNone"><code>std::queue</code> + mutex   </td><td class="markdownTableBodyNone"><code>std::queue</code> + mutex   </td><td class="markdownTableBodyNone">Lock-free queue    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Memory Pooling</b>   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">Yes (configurable)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Batch Processing</b>   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">Yes (dynamic sizing)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>jthread Support</b>   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">Yes (with fallback)   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Performance Stats</b>   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">Dropped count only   </td><td class="markdownTableBodyNone">Full statistics    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Recommended For</b>   </td><td class="markdownTableBodyNone">Most use cases   </td><td class="markdownTableBodyNone">Internal components   </td><td class="markdownTableBodyNone">High-volume logging   </td></tr>
</table>
<hr  />
<h1><a class="anchor" id="autotoc_md195"></a>
Detailed Descriptions</h1>
<h2><a class="anchor" id="autotoc_md196"></a>
1. async_writer (Public API)</h2>
<p><b>Location:</b> <code>include/kcenon/logger/writers/async_writer.h</code></p>
<p>The <code>async_writer</code> is the <b>recommended choice for most applications</b>. It wraps any <code>base_writer</code> implementation and provides asynchronous writing capabilities using a background thread.</p>
<h3><a class="anchor" id="autotoc_md197"></a>
Key Features</h3>
<ul>
<li><b>Universal wrapper</b>: Works with any <code>base_writer</code> (console, file, network, etc.)</li>
<li><b>Configurable queue size</b>: Default 10,000 messages</li>
<li><b>Configurable flush timeout</b>: Default 5 seconds</li>
<li><b>Graceful shutdown</b>: Processes remaining messages on stop</li>
<li><b>Thread-safe</b>: Safe for concurrent writes from multiple threads</li>
</ul>
<h3><a class="anchor" id="autotoc_md198"></a>
Architecture</h3>
<div class="fragment"><div class="line">┌─────────────┐     ┌──────────────┐     ┌────────────────┐</div>
<div class="line">│ Application │────►│ async_writer │────►│ wrapped_writer │</div>
<div class="line">│   Threads   │     │   (queue)    │     │  (any writer)  │</div>
<div class="line">└─────────────┘     └──────┬───────┘     └────────────────┘</div>
<div class="line">                           │</div>
<div class="line">                    ┌──────┴───────┐</div>
<div class="line">                    │ Worker Thread│</div>
<div class="line">                    └──────────────┘</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md199"></a>
API Reference</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>async_writer : <span class="keyword">public</span> base_writer {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Constructor</span></div>
<div class="line">    <span class="keyword">explicit</span> async_writer(</div>
<div class="line">        std::unique_ptr&lt;base_writer&gt; wrapped_writer,</div>
<div class="line">        std::size_t queue_size = 10000,</div>
<div class="line">        std::chrono::seconds flush_timeout = std::chrono::seconds(5));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Control methods</span></div>
<div class="line">    <span class="keywordtype">void</span> start();                        <span class="comment">// Start worker thread</span></div>
<div class="line">    <span class="keywordtype">void</span> stop(<span class="keywordtype">bool</span> force_flush = <span class="keyword">true</span>);  <span class="comment">// Stop with optional flush</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// base_writer interface</span></div>
<div class="line">    common::VoidResult write(...) <span class="keyword">override</span>;</div>
<div class="line">    common::VoidResult flush() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> is_healthy() <span class="keyword">const override</span>;</div>
<div class="line">    std::string get_name() <span class="keyword">const override</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md200"></a>
When to Use</h3>
<ul>
<li>Standard async logging requirements</li>
<li>Wrapping slow writers (file, network)</li>
<li>Applications with moderate logging volume (&lt;100K msg/sec)</li>
<li>When simplicity is preferred over maximum performance</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md202"></a>
2. async_worker (Internal)</h2>
<p><b>Location:</b> <code>src/impl/async/async_worker.h</code></p>
<p>The <code>async_worker</code> is a <b>low-level component</b> used internally for task-based asynchronous processing. It's designed for internal use and provides a foundation for building async components.</p>
<h3><a class="anchor" id="autotoc_md203"></a>
Key Features</h3>
<ul>
<li><b>Task-based processing</b>: Uses <code>std::function&lt;void()&gt;</code> for flexibility</li>
<li><b>jthread compatibility</b>: Uses <code>std::jthread</code> where available, with fallback</li>
<li><b>Cooperative cancellation</b>: Graceful shutdown via stop tokens</li>
<li><b>Dropped task tracking</b>: Monitors queue overflow</li>
</ul>
<h3><a class="anchor" id="autotoc_md204"></a>
Architecture</h3>
<div class="fragment"><div class="line">┌──────────────┐     ┌──────────────┐</div>
<div class="line">│ Task Sources │────►│ async_worker │────► Execute tasks</div>
<div class="line">│  (internal)  │     │   (queue)    │      sequentially</div>
<div class="line">└──────────────┘     └──────────────┘</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md205"></a>
When to Use</h3>
<ul>
<li>Building internal async components</li>
<li>Custom task processing requirements</li>
<li>Integration with other async systems</li>
</ul>
<blockquote class="doxtable">
<p>&zwj;<b>Note:</b> This is an internal API and may change without notice. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md206"></a>
&lt;/blockquote&gt;</h1>
<h2><a class="anchor" id="autotoc_md207"></a>
3. high_performance_async_writer (Internal)</h2>
<p><b>Location:</b> <code>src/impl/async/high_performance_async_writer.h</code></p>
<p>The <code>high_performance_async_writer</code> is optimized for <b>maximum throughput</b> scenarios. It combines lock-free queues, memory pooling, and batch processing for high-volume logging.</p>
<h3><a class="anchor" id="autotoc_md208"></a>
Key Features</h3>
<ul>
<li><b>Lock-free queue</b>: Minimizes contention in high-concurrency scenarios</li>
<li><b>Memory pooling</b>: Reduces allocation overhead</li>
<li><b>Dynamic batch processing</b>: Adapts batch size based on load</li>
<li><b>Back-pressure handling</b>: Configurable queue full behavior</li>
<li><b>Performance statistics</b>: Detailed metrics (latency, throughput, success ratio)</li>
</ul>
<h3><a class="anchor" id="autotoc_md209"></a>
Architecture</h3>
<div class="fragment"><div class="line">┌─────────────┐     ┌─────────────────────────────────────┐</div>
<div class="line">│ Application │     │  high_performance_async_writer      │</div>
<div class="line">│   Threads   │────►│  ┌─────────────┐  ┌──────────────┐ │</div>
<div class="line">└─────────────┘     │  │ Lock-free   │  │ Batch        │ │</div>
<div class="line">                    │  │ Queue       │─►│ Processor    │─┼──► Writer</div>
<div class="line">                    │  └─────────────┘  └──────────────┘ │</div>
<div class="line">                    │  ┌─────────────┐                   │</div>
<div class="line">                    │  │ Memory Pool │                   │</div>
<div class="line">                    │  └─────────────┘                   │</div>
<div class="line">                    └─────────────────────────────────────┘</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md210"></a>
Configuration</h3>
<div class="fragment"><div class="line"><span class="keyword">struct </span>config {</div>
<div class="line">    <span class="comment">// Queue configuration</span></div>
<div class="line">    <span class="keywordtype">size_t</span> queue_size{8192};              <span class="comment">// Must be power of 2</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Batch processing</span></div>
<div class="line">    batch_processor::config batch_config;</div>
<div class="line">    <span class="comment">// - initial_batch_size: 50</span></div>
<div class="line">    <span class="comment">// - max_batch_size: 500</span></div>
<div class="line">    <span class="comment">// - min_batch_size: 10</span></div>
<div class="line">    <span class="comment">// - max_wait_time: 100ms</span></div>
<div class="line">    <span class="comment">// - enable_dynamic_sizing: true</span></div>
<div class="line">    <span class="comment">// - enable_back_pressure: true</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Memory pool</span></div>
<div class="line">    memory::object_pool&lt;...&gt;::config pool_config;</div>
<div class="line">    <span class="comment">// - initial_size: 200</span></div>
<div class="line">    <span class="comment">// - max_size: 2000</span></div>
<div class="line">    <span class="comment">// - allow_growth: true</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Features</span></div>
<div class="line">    <span class="keywordtype">bool</span> enable_memory_pooling{<span class="keyword">true</span>};</div>
<div class="line">    <span class="keywordtype">bool</span> enable_batch_processing{<span class="keyword">true</span>};</div>
<div class="line">    std::chrono::microseconds flush_timeout{1000};</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md211"></a>
When to Use</h3>
<ul>
<li>Logging &gt;100K messages per second</li>
<li>Latency-sensitive applications</li>
<li>Systems with high thread contention</li>
<li>When detailed performance metrics are needed</li>
</ul>
<blockquote class="doxtable">
<p>&zwj;<b>Note:</b> This is currently an internal API. Contact maintainers for production use guidance. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md212"></a>
&lt;/blockquote&gt;</h1>
<h1><a class="anchor" id="autotoc_md213"></a>
Performance Characteristics</h1>
<h2><a class="anchor" id="autotoc_md214"></a>
Benchmark Comparison</h2>
<p><b>Test Environment:</b> Apple M1 (8-core), 16GB RAM, macOS</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Metric   </th><th class="markdownTableHeadNone">async_writer   </th><th class="markdownTableHeadNone">high_performance_async_writer    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Single-thread throughput</b>   </td><td class="markdownTableBodyNone">~500K msg/s   </td><td class="markdownTableBodyNone">~2M msg/s    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>8-thread throughput</b>   </td><td class="markdownTableBodyNone">~200K msg/s   </td><td class="markdownTableBodyNone">~800K msg/s    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Average enqueue latency</b>   </td><td class="markdownTableBodyNone">~500 ns   </td><td class="markdownTableBodyNone">~150 ns    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Memory overhead</b>   </td><td class="markdownTableBodyNone">Low   </td><td class="markdownTableBodyNone">Medium (pool)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Queue full behavior</b>   </td><td class="markdownTableBodyNone">Returns error   </td><td class="markdownTableBodyNone">Back-pressure   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md215"></a>
Latency Distribution</h2>
<div class="fragment"><div class="line">async_writer:</div>
<div class="line">  P50: 400 ns</div>
<div class="line">  P99: 2 μs</div>
<div class="line">  P99.9: 10 μs</div>
<div class="line"> </div>
<div class="line">high_performance_async_writer:</div>
<div class="line">  P50: 100 ns</div>
<div class="line">  P99: 500 ns</div>
<div class="line">  P99.9: 2 μs</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md217"></a>
Usage Examples</h1>
<h2><a class="anchor" id="autotoc_md218"></a>
Example 1: Basic async_writer Usage</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/async_writer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/file_writer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create async file writer</span></div>
<div class="line"><span class="keyword">auto</span> file_writer = std::make_unique&lt;kcenon::logger::file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> async = std::make_unique&lt;kcenon::logger::async_writer&gt;(</div>
<div class="line">    std::move(file_writer),</div>
<div class="line">    10000,  <span class="comment">// queue size</span></div>
<div class="line">    std::chrono::seconds(5)  <span class="comment">// flush timeout</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Start the async writer</span></div>
<div class="line">async-&gt;start();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use the writer</span></div>
<div class="line">async-&gt;write(log_level::info, <span class="stringliteral">&quot;Hello async!&quot;</span>, __FILE__, __LINE__, __func__,</div>
<div class="line">             std::chrono::system_clock::now());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Flush and stop</span></div>
<div class="line">async-&gt;flush();</div>
<div class="line">async-&gt;stop();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md219"></a>
Example 2: async_writer with Console Output</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/async_writer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/console_writer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wrap console writer for async operation</span></div>
<div class="line"><span class="keyword">auto</span> console = std::make_unique&lt;kcenon::logger::console_writer&gt;();</div>
<div class="line"><span class="keyword">auto</span> async_console = std::make_unique&lt;kcenon::logger::async_writer&gt;(</div>
<div class="line">    std::move(console),</div>
<div class="line">    5000  <span class="comment">// smaller queue for console</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">async_console-&gt;start();</div>
<div class="line"><span class="comment">// ... use async_console ...</span></div>
<div class="line">async_console-&gt;stop(<span class="keyword">true</span>);  <span class="comment">// flush remaining messages</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md220"></a>
Example 3: Queue Full Handling</h2>
<div class="fragment"><div class="line"><span class="keyword">auto</span> async = std::make_unique&lt;kcenon::logger::async_writer&gt;(</div>
<div class="line">    std::make_unique&lt;kcenon::logger::file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>),</div>
<div class="line">    1000  <span class="comment">// small queue for demonstration</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">async-&gt;start();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Write with error handling</span></div>
<div class="line"><span class="keyword">auto</span> result = async-&gt;write(log_level::info, <span class="stringliteral">&quot;Message&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, 0, <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">                           std::chrono::system_clock::now());</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!result.is_ok()) {</div>
<div class="line">    <span class="keywordflow">if</span> (result.error().code() == logger_error_code::queue_full) {</div>
<div class="line">        <span class="comment">// Handle queue full - maybe write synchronously or drop</span></div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Async queue full, message dropped\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md221"></a>
Example 4: Graceful Shutdown Pattern</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>application {</div>
<div class="line">    std::unique_ptr&lt;async_writer&gt; logger_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    application() {</div>
<div class="line">        <span class="keyword">auto</span> writer = std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>);</div>
<div class="line">        logger_ = std::make_unique&lt;async_writer&gt;(std::move(writer));</div>
<div class="line">        logger_-&gt;start();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ~application() {</div>
<div class="line">        <span class="comment">// Ensure all logs are flushed on shutdown</span></div>
<div class="line">        <span class="keywordflow">if</span> (logger_) {</div>
<div class="line">            logger_-&gt;flush();  <span class="comment">// Wait for queue to empty</span></div>
<div class="line">            logger_-&gt;stop(<span class="keyword">true</span>);  <span class="comment">// Stop with flush</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> log(<span class="keyword">const</span> std::string&amp; message) {</div>
<div class="line">        logger_-&gt;write(log_level::info, message, <span class="stringliteral">&quot;&quot;</span>, 0, <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">                       std::chrono::system_clock::now());</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md223"></a>
Best Practices</h1>
<h2><a class="anchor" id="autotoc_md224"></a>
1. Queue Size Selection</h2>
<div class="fragment"><div class="line"><span class="comment">// Low volume (&lt;1K msg/sec): Small queue</span></div>
<div class="line">async_writer(writer, 1000);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Medium volume (1K-10K msg/sec): Default</span></div>
<div class="line">async_writer(writer, 10000);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// High volume (&gt;10K msg/sec): Large queue</span></div>
<div class="line">async_writer(writer, 100000);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md225"></a>
2. Flush Timeout Configuration</h2>
<div class="fragment"><div class="line"><span class="comment">// Fast flush requirement (interactive apps)</span></div>
<div class="line">async_writer(writer, 10000, std::chrono::seconds(1));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Standard applications</span></div>
<div class="line">async_writer(writer, 10000, std::chrono::seconds(5));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Batch-oriented (background services)</span></div>
<div class="line">async_writer(writer, 10000, std::chrono::seconds(30));</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md226"></a>
3. Error Handling</h2>
<p>Always check the result of <code>write()</code> operations:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> result = async-&gt;write(...);</div>
<div class="line"><span class="keywordflow">if</span> (!result.is_ok()) {</div>
<div class="line">    <span class="comment">// Fallback: write synchronously or drop</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md227"></a>
4. Lifecycle Management</h2>
<ul>
<li>Call <code>start()</code> before any writes</li>
<li>Call <code>flush()</code> before <code>stop()</code> if you need all messages written</li>
<li>Use RAII patterns for automatic cleanup</li>
</ul>
<h2><a class="anchor" id="autotoc_md228"></a>
5. Thread Safety Considerations</h2>
<ul>
<li><code>async_writer</code> is thread-safe for writes</li>
<li>Avoid calling <code>start()</code>/<code>stop()</code> concurrently</li>
<li>Use external synchronization for configuration changes</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md230"></a>
Migration Guide</h1>
<h2><a class="anchor" id="autotoc_md231"></a>
From Synchronous to async_writer</h2>
<p><b>Before:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>);</div>
<div class="line">writer-&gt;write(level, message, file, line, func, timestamp);</div>
</div><!-- fragment --><p><b>After:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> writer = std::make_unique&lt;file_writer&gt;(<span class="stringliteral">&quot;app.log&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> async = std::make_unique&lt;async_writer&gt;(std::move(writer));</div>
<div class="line">async-&gt;start();</div>
<div class="line">async-&gt;write(level, message, file, line, func, timestamp);</div>
<div class="line"><span class="comment">// Don&#39;t forget: async-&gt;stop() on shutdown</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md232"></a>
Queue Full Migration</h2>
<p>If experiencing queue full errors:</p>
<ol type="1">
<li><b>Increase queue size:</b> <div class="fragment"><div class="line">async_writer(writer, 50000);  <span class="comment">// 5x default</span></div>
</div><!-- fragment --></li>
<li><b>Add back-pressure handling:</b> <div class="fragment"><div class="line"><span class="keywordflow">while</span> (!async-&gt;write(...).is_ok()) {</div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(1));</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><b>Consider high_performance_async_writer</b> for extreme cases</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md234"></a>
Related Documentation</h1>
<ul>
<li><a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2advanced_2CUSTOM__WRITERS.html">Custom Writers Guide</a> - Creating custom writer implementations</li>
<li><a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2advanced_2ARCHITECTURE.html">Architecture Overview</a> - System architecture and design</li>
<li><a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2BENCHMARKS.html">Performance Benchmarks</a> - Detailed performance analysis</li>
<li><a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2integration_2THREAD__SYSTEM.html">Thread System Integration</a> - Thread system integration</li>
</ul>
<hr  />
<p><b>Maintainer:</b> <a href="#" onclick="location.href='mai'+'lto:'+'kce'+'no'+'n@n'+'av'+'er.'+'co'+'m'; return false;">kceno<span class="obfuscator">.nosp@m.</span>n@na<span class="obfuscator">.nosp@m.</span>ver.c<span class="obfuscator">.nosp@m.</span>om</a> <b>Issue Tracker:</b> <a href="https://github.com/kcenon/logger_system/issues">GitHub Issues</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Jan 20 2026 14:39:52 for Logger System by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
