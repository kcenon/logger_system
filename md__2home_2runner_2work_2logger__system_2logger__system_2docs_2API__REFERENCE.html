<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Logger System: API_REFERENCE</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Logger System<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-performance C++20 thread-safe logging system with asynchronous capabilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__2home_2runner_2work_2logger__system_2logger__system_2docs_2API__REFERENCE.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">API_REFERENCE</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><blockquote class="doxtable">
<p>&zwj;<b>Language:</b> <b>English</b> | <a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2API__REFERENCE_8kr.html">한국어</a> </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md701"></a>
API Reference</h1>
<p><b>Version</b>: 3.0.0 <b>Last Updated</b>: 2025-12-10</p>
<h2><a class="anchor" id="autotoc_md702"></a>
Table of Contents</h2>
<ul>
<li>Overview</li>
<li>Core Classes</li>
<li>ILogger Interface (Phase 2.0)</li>
<li>Configuration</li>
<li>Builder Pattern</li>
<li>Configuration Strategies</li>
<li>Interfaces</li>
<li>Error Handling</li>
<li>Writers</li>
<li>Filters</li>
<li>Formatters</li>
<li>Backend Integration</li>
<li>Monitoring Integration</li>
</ul>
<h2><a class="anchor" id="autotoc_md703"></a>
Overview</h2>
<p>The Logger System (v3.0) provides a high-performance, thread-safe logging framework with:</p>
<ul>
<li><b>Dual API Design</b>: Supports both <code>common::interfaces::ILogger</code> (standardized) and native <code>logger_system::log_level</code> (backward compatible)</li>
<li><b>Standalone Mode</b>: No external dependencies required (uses <code>std::jthread</code> internally)</li>
<li><b>Optional Integration</b>: Thread_system integration is optional since v3.0</li>
<li><b>C++20 Features</b>: Leverages Concepts and <code>source_location</code> for enhanced developer experience</li>
</ul>
<h3><a class="anchor" id="autotoc_md704"></a>
Namespace</h3>
<p>All classes are in the <code>kcenon::logger</code> namespace:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/core/logger.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;kcenon/logger/core/logger_builder.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/console_writer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>kcenon::logger;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md705"></a>
Core Classes</h2>
<h3><a class="anchor" id="autotoc_md706"></a>
&lt;tt&gt;kcenon::logger::logger&lt;/tt&gt;</h3>
<p>The main logger class that handles all logging operations. Implements both <code>common::interfaces::ILogger</code> for standardized interface and <code>security::critical_logger_interface</code> for crash-safe logging.</p>
<h4><a class="anchor" id="autotoc_md707"></a>
Constructor</h4>
<div class="fragment"><div class="line"><span class="keyword">explicit</span> logger(<span class="keywordtype">bool</span> async = <span class="keyword">true</span>,</div>
<div class="line">                std::size_t buffer_size = 8192,</div>
<div class="line">                std::unique_ptr&lt;backends::integration_backend&gt; backend = <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><p><b>Parameters:</b></p><ul>
<li><code>async</code>: Enable asynchronous logging (default: true)</li>
<li><code>buffer_size</code>: Size of the log buffer in bytes (default: 8192)</li>
<li><code>backend</code>: Integration backend for async processing (default: auto-detected standalone backend)</li>
</ul>
<h4><a class="anchor" id="autotoc_md708"></a>
Destructor</h4>
<div class="fragment"><div class="line">~logger();</div>
</div><!-- fragment --><p>Ensures all buffered messages are flushed before destruction.</p>
<h2><a class="anchor" id="autotoc_md709"></a>
ILogger Interface (Phase 2.0)</h2>
<p>Since v2.0, the logger implements <code>common::interfaces::ILogger</code> for standardized logging across the unified_system ecosystem.</p>
<h3><a class="anchor" id="autotoc_md710"></a>
Log Methods (ILogger Interface)</h3>
<div class="fragment"><div class="line"><span class="comment">// Simple message logging</span></div>
<div class="line">common::VoidResult log(common::interfaces::log_level level,</div>
<div class="line">                       <span class="keyword">const</span> std::string&amp; message) <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// With C++20 source_location (recommended)</span></div>
<div class="line">common::VoidResult log(common::interfaces::log_level level,</div>
<div class="line">                       std::string_view message,</div>
<div class="line">                       <span class="keyword">const</span> common::source_location&amp; loc = common::source_location::current()) <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// With explicit source location (legacy)</span></div>
<div class="line">common::VoidResult log(common::interfaces::log_level level,</div>
<div class="line">                       <span class="keyword">const</span> std::string&amp; message,</div>
<div class="line">                       <span class="keyword">const</span> std::string&amp; file,</div>
<div class="line">                       <span class="keywordtype">int</span> line,</div>
<div class="line">                       <span class="keyword">const</span> std::string&amp; function) <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Structured log entry</span></div>
<div class="line">common::VoidResult log(<span class="keyword">const</span> common::interfaces::log_entry&amp; entry) <span class="keyword">override</span>;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md711"></a>
Level Management (ILogger Interface)</h3>
<div class="fragment"><div class="line"><span class="comment">// Check if level is enabled</span></div>
<div class="line"><span class="keywordtype">bool</span> is_enabled(common::interfaces::log_level level) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set minimum log level</span></div>
<div class="line">common::VoidResult set_level(common::interfaces::log_level level) <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get current minimum log level</span></div>
<div class="line">common::interfaces::log_level get_level() <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Flush buffered messages</span></div>
<div class="line">common::VoidResult flush() <span class="keyword">override</span>;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md712"></a>
Native API (Backward Compatible)</h3>
<p>For backward compatibility with logger_system native types:</p>
<div class="fragment"><div class="line"><span class="comment">// Log with native log_level</span></div>
<div class="line"><span class="keywordtype">void</span> log(log_level level, <span class="keyword">const</span> std::string&amp; message);</div>
<div class="line"><span class="keywordtype">void</span> log(log_level level, <span class="keyword">const</span> std::string&amp; message,</div>
<div class="line">         <span class="keyword">const</span> std::string&amp; file, <span class="keywordtype">int</span> line, <span class="keyword">const</span> std::string&amp; function);</div>
<div class="line"><span class="keywordtype">void</span> log(log_level level, <span class="keyword">const</span> std::string&amp; message,</div>
<div class="line">         <span class="keyword">const</span> core::log_context&amp; context);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check level with native log_level</span></div>
<div class="line"><span class="keywordtype">bool</span> is_enabled(log_level level) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set/get minimum level (legacy)</span></div>
<div class="line"><span class="keywordtype">void</span> set_min_level(log_level level);  <span class="comment">// Deprecated: use set_level()</span></div>
<div class="line">log_level get_min_level() <span class="keyword">const</span>;      <span class="comment">// Deprecated: use get_level()</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md713"></a>
Writer Management</h3>
<div class="fragment"><div class="line"><span class="comment">// Add writer (unnamed)</span></div>
<div class="line">common::VoidResult add_writer(std::unique_ptr&lt;base_writer&gt; writer);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add writer with name (stores for later retrieval/removal)</span></div>
<div class="line">common::VoidResult add_writer(<span class="keyword">const</span> std::string&amp; name, std::unique_ptr&lt;base_writer&gt; writer);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Remove writer by name</span></div>
<div class="line"><span class="keywordtype">bool</span> remove_writer(<span class="keyword">const</span> std::string&amp; name);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get writer by name</span></div>
<div class="line">base_writer* get_writer(<span class="keyword">const</span> std::string&amp; name);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Remove all writers</span></div>
<div class="line">common::VoidResult clear_writers();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md714"></a>
Lifecycle Management</h3>
<div class="fragment"><div class="line"><span class="comment">// Start async processing</span></div>
<div class="line">common::VoidResult start();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Stop async processing</span></div>
<div class="line">common::VoidResult stop();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check if running</span></div>
<div class="line"><span class="keywordtype">bool</span> is_running() <span class="keyword">const</span>;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md715"></a>
Metrics</h3>
<div class="fragment"><div class="line"><span class="comment">// Enable/disable metrics</span></div>
<div class="line">common::VoidResult enable_metrics_collection(<span class="keywordtype">bool</span> enable = <span class="keyword">true</span>);</div>
<div class="line"><span class="keywordtype">bool</span> is_metrics_collection_enabled() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get metrics</span></div>
<div class="line">result&lt;metrics::logger_performance_stats&gt; get_current_metrics() <span class="keyword">const</span>;</div>
<div class="line">result&lt;std::unique_ptr&lt;metrics::logger_performance_stats&gt;&gt; get_metrics_history(</div>
<div class="line">    std::chrono::seconds duration) <span class="keyword">const</span>;</div>
<div class="line">common::VoidResult reset_metrics();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md716"></a>
Filtering</h3>
<div class="fragment"><div class="line"><span class="comment">// Set global filter</span></div>
<div class="line"><span class="keywordtype">void</span> set_filter(std::unique_ptr&lt;log_filter_interface&gt; filter);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check if filter is set</span></div>
<div class="line"><span class="keywordtype">bool</span> has_filter() <span class="keyword">const</span>;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md717"></a>
Emergency Flush (Signal Safety)</h3>
<div class="fragment"><div class="line"><span class="comment">// Get file descriptor for emergency writing</span></div>
<div class="line"><span class="keywordtype">int</span> get_emergency_fd() <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get emergency buffer</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* get_emergency_buffer() <span class="keyword">const override</span>;</div>
<div class="line"><span class="keywordtype">size_t</span> get_emergency_buffer_size() <span class="keyword">const override</span>;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md718"></a>
Configuration</h2>
<h3><a class="anchor" id="autotoc_md719"></a>
&lt;tt&gt;kcenon::logger::logger_config&lt;/tt&gt;</h3>
<p>Configuration structure with validation capabilities.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>logger_config {</div>
<div class="line">    <span class="comment">// Basic settings</span></div>
<div class="line">    <span class="keywordtype">bool</span> async = <span class="keyword">true</span>;</div>
<div class="line">    std::size_t buffer_size = 8192;</div>
<div class="line">    logger_system::log_level min_level = logger_system::log_level::info;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Performance settings</span></div>
<div class="line">    std::size_t batch_size = 100;</div>
<div class="line">    std::chrono::milliseconds flush_interval{1000};</div>
<div class="line">    <span class="keywordtype">bool</span> use_lock_free = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> enable_batch_writing = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Feature flags</span></div>
<div class="line">    <span class="keywordtype">bool</span> enable_metrics = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> enable_crash_handler = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> enable_structured_logging = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> enable_color_output = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> enable_timestamp = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> enable_source_location = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Queue settings</span></div>
<div class="line">    std::size_t max_queue_size = 10000;</div>
<div class="line">    overflow_policy queue_overflow_policy = overflow_policy::drop_newest;</div>
<div class="line">    std::size_t max_writers = 16;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// File settings</span></div>
<div class="line">    std::string log_directory = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">    std::string log_file_prefix = <span class="stringliteral">&quot;app&quot;</span>;</div>
<div class="line">    std::size_t max_file_size = 100 * 1024 * 1024;  <span class="comment">// 100MB</span></div>
<div class="line">    std::size_t max_file_count = 5;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Network settings</span></div>
<div class="line">    std::string remote_host = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">    uint16_t remote_port = 0;</div>
<div class="line">    std::chrono::milliseconds network_timeout{5000};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Validation</span></div>
<div class="line">    common::VoidResult validate() <span class="keyword">const</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md720"></a>
Static Factory Methods</h3>
<div class="fragment"><div class="line"><span class="keyword">static</span> logger_config default_config();</div>
<div class="line"><span class="keyword">static</span> logger_config production();</div>
<div class="line"><span class="keyword">static</span> logger_config debug_config();</div>
<div class="line"><span class="keyword">static</span> logger_config high_performance();</div>
<div class="line"><span class="keyword">static</span> logger_config low_latency();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md721"></a>
Builder Pattern</h2>
<h3><a class="anchor" id="autotoc_md722"></a>
&lt;tt&gt;kcenon::logger::logger_builder&lt;/tt&gt;</h3>
<p>Fluent interface for constructing logger instances with validation.</p>
<h4><a class="anchor" id="autotoc_md723"></a>
Basic Configuration</h4>
<div class="fragment"><div class="line">logger_builder&amp; with_config(<span class="keyword">const</span> logger_config&amp; config);</div>
<div class="line">logger_builder&amp; use_template(<span class="keyword">const</span> std::string&amp; template_name);</div>
<div class="line">logger_builder&amp; with_async(<span class="keywordtype">bool</span> async = <span class="keyword">true</span>);</div>
<div class="line">logger_builder&amp; with_buffer_size(std::size_t size);</div>
<div class="line">logger_builder&amp; with_min_level(logger_system::log_level level);</div>
<div class="line">logger_builder&amp; with_batch_size(std::size_t size);</div>
<div class="line">logger_builder&amp; with_batch_writing(<span class="keywordtype">bool</span> enable = <span class="keyword">true</span>);</div>
<div class="line">logger_builder&amp; with_flush_interval(std::chrono::milliseconds interval);</div>
<div class="line">logger_builder&amp; with_lock_free(<span class="keywordtype">bool</span> enable = <span class="keyword">true</span>);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md724"></a>
Feature Flags</h4>
<div class="fragment"><div class="line">logger_builder&amp; with_metrics(<span class="keywordtype">bool</span> enable = <span class="keyword">true</span>);</div>
<div class="line">logger_builder&amp; with_crash_handler(<span class="keywordtype">bool</span> enable = <span class="keyword">true</span>);</div>
<div class="line">logger_builder&amp; with_structured_logging(<span class="keywordtype">bool</span> enable = <span class="keyword">true</span>);</div>
<div class="line">logger_builder&amp; with_overflow_policy(logger_config::overflow_policy policy);</div>
<div class="line">logger_builder&amp; with_max_queue_size(std::size_t size);</div>
<div class="line">logger_builder&amp; with_default_pattern();</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md725"></a>
Output Configuration</h4>
<div class="fragment"><div class="line">logger_builder&amp; with_file_output(<span class="keyword">const</span> std::string&amp; directory,</div>
<div class="line">                                 <span class="keyword">const</span> std::string&amp; prefix = <span class="stringliteral">&quot;app&quot;</span>,</div>
<div class="line">                                 std::size_t max_size = 100 * 1024 * 1024,</div>
<div class="line">                                 std::size_t max_count = 5);</div>
<div class="line">logger_builder&amp; with_network_output(<span class="keyword">const</span> std::string&amp; host,</div>
<div class="line">                                    uint16_t port,</div>
<div class="line">                                    std::chrono::milliseconds timeout =</div>
<div class="line">                                        std::chrono::milliseconds(5000));</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md726"></a>
Writers and Filters</h4>
<div class="fragment"><div class="line">logger_builder&amp; add_writer(<span class="keyword">const</span> std::string&amp; name,</div>
<div class="line">                           std::unique_ptr&lt;base_writer&gt; writer);</div>
<div class="line">logger_builder&amp; add_filter(std::unique_ptr&lt;log_filter_interface&gt; filter);</div>
<div class="line">logger_builder&amp; add_level_filter(logger_system::log_level min_level);</div>
<div class="line">logger_builder&amp; add_regex_filter(<span class="keyword">const</span> std::string&amp; pattern,</div>
<div class="line">                                 <span class="keywordtype">bool</span> include_matches = <span class="keyword">true</span>);</div>
<div class="line">logger_builder&amp; add_function_filter(</div>
<div class="line">    std::function&lt;<span class="keywordtype">bool</span>(<span class="keyword">const</span> log_entry&amp;)&gt; predicate);</div>
<div class="line">logger_builder&amp; with_formatter(std::unique_ptr&lt;log_formatter_interface&gt; formatter);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md727"></a>
Backend Selection</h4>
<div class="fragment"><div class="line"><span class="comment">// Use custom backend</span></div>
<div class="line">logger_builder&amp; with_backend(std::unique_ptr&lt;backends::integration_backend&gt; backend);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use standalone backend explicitly (default)</span></div>
<div class="line">logger_builder&amp; with_standalone_backend();</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md728"></a>
Environment and Error Handling</h4>
<div class="fragment"><div class="line">logger_builder&amp; detect_environment();</div>
<div class="line">logger_builder&amp; auto_configure();</div>
<div class="line">logger_builder&amp; with_error_handler(</div>
<div class="line">    std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> logger_error_code&amp;)&gt; handler);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md729"></a>
Build</h4>
<div class="fragment"><div class="line">common::VoidResult validate() <span class="keyword">const</span>;</div>
<div class="line">result&lt;std::unique_ptr&lt;logger&gt;&gt; build();</div>
<div class="line"><span class="keyword">const</span> logger_config&amp; get_config() <span class="keyword">const</span>;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md730"></a>
Configuration Strategies</h2>
<h3><a class="anchor" id="autotoc_md731"></a>
Deployment Strategy</h3>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> deployment_env {</div>
<div class="line">    development,</div>
<div class="line">    staging,</div>
<div class="line">    production,</div>
<div class="line">    testing</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">logger_builder&amp; for_environment(deployment_env env);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md732"></a>
Performance Strategy</h3>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> performance_level {</div>
<div class="line">    low_latency,</div>
<div class="line">    balanced,</div>
<div class="line">    high_throughput,</div>
<div class="line">    minimal_overhead</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">logger_builder&amp; with_performance_tuning(performance_level level);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md733"></a>
Environment Strategy</h3>
<div class="fragment"><div class="line"><span class="comment">// Auto-configure from LOG_* environment variables</span></div>
<div class="line">logger_builder&amp; auto_configure();</div>
</div><!-- fragment --><p>Supported environment variables:</p><ul>
<li><code>LOG_LEVEL</code>: trace, debug, info, warn, error, fatal</li>
<li><code>LOG_ASYNC</code>: true/false</li>
<li><code>LOG_BUFFER_SIZE</code>: buffer size in bytes</li>
<li><code>LOG_BATCH_SIZE</code>: batch size</li>
<li><code>LOG_FLUSH_INTERVAL</code>: flush interval in ms</li>
<li><code>LOG_COLOR</code>: true/false</li>
<li><code>LOG_METRICS</code>: true/false</li>
<li><code>LOG_ENV</code>: production/staging/development/testing</li>
</ul>
<h3><a class="anchor" id="autotoc_md734"></a>
Composite Strategy</h3>
<div class="fragment"><div class="line">logger_builder&amp; apply_strategy(std::unique_ptr&lt;config_strategy_interface&gt; strategy);</div>
<div class="line">logger_builder&amp; clear_strategies();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md735"></a>
Interfaces</h2>
<h3><a class="anchor" id="autotoc_md736"></a>
&lt;tt&gt;kcenon::logger::log_writer_interface&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>log_writer_interface {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~log_writer_interface() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> common::VoidResult write(<span class="keyword">const</span> log_entry&amp; entry) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> common::VoidResult flush() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> is_healthy()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md737"></a>
&lt;tt&gt;kcenon::logger::log_filter_interface&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>log_filter_interface {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~log_filter_interface() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> should_log(<span class="keyword">const</span> log_entry&amp; entry) <span class="keyword">const</span> = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md738"></a>
&lt;tt&gt;kcenon::logger::log_formatter_interface&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>log_formatter_interface {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~log_formatter_interface() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> std::string format(<span class="keyword">const</span> log_entry&amp; entry) <span class="keyword">const</span> = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md739"></a>
&lt;tt&gt;kcenon::logger::log_entry&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="keyword">struct </span>log_entry {</div>
<div class="line">    logger_system::log_level level;</div>
<div class="line">    std::string message;</div>
<div class="line">    std::string file;</div>
<div class="line">    <span class="keywordtype">int</span> line;</div>
<div class="line">    std::string function;</div>
<div class="line">    std::chrono::system_clock::time_point timestamp;</div>
<div class="line">    std::thread::id thread_id;</div>
<div class="line">    std::unordered_map&lt;std::string, std::string&gt; context;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md740"></a>
Error Handling</h2>
<h3><a class="anchor" id="autotoc_md741"></a>
Error Codes</h3>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> logger_error_code {</div>
<div class="line">    <span class="comment">// General errors</span></div>
<div class="line">    success = 0,</div>
<div class="line">    unknown_error = 1,</div>
<div class="line">    not_implemented = 2,</div>
<div class="line">    invalid_argument = 3,</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Writer errors (1000-1099)</span></div>
<div class="line">    writer_not_found = 1000,</div>
<div class="line">    writer_initialization_failed = 1001,</div>
<div class="line">    writer_already_exists = 1002,</div>
<div class="line">    writer_not_healthy = 1003,</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// File errors (1100-1199)</span></div>
<div class="line">    file_open_failed = 1100,</div>
<div class="line">    file_write_failed = 1101,</div>
<div class="line">    file_rotation_failed = 1102,</div>
<div class="line">    file_permission_denied = 1103,</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Network errors (1200-1299)</span></div>
<div class="line">    network_connection_failed = 1200,</div>
<div class="line">    network_send_failed = 1201,</div>
<div class="line">    network_timeout = 1202,</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Buffer/Queue errors (1300-1399)</span></div>
<div class="line">    buffer_overflow = 1300,</div>
<div class="line">    queue_full = 1301,</div>
<div class="line">    queue_stopped = 1302,</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Configuration errors (1400-1499)</span></div>
<div class="line">    invalid_configuration = 1400,</div>
<div class="line">    configuration_missing = 1401,</div>
<div class="line">    configuration_conflict = 1402</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md742"></a>
Result Types</h3>
<p>The logger uses <code>common::Result&lt;T&gt;</code> and <code>common::VoidResult</code> from common_system:</p>
<div class="fragment"><div class="line"><span class="comment">// Success</span></div>
<div class="line"><span class="keywordflow">return</span> common::VoidResult{};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Error</span></div>
<div class="line"><span class="keywordflow">return</span> common::make_error&lt;void&gt;(</div>
<div class="line">    common::ErrorCategory::Logger,</div>
<div class="line">    <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(logger_error_code::queue_full),</div>
<div class="line">    <span class="stringliteral">&quot;Queue is full&quot;</span></div>
<div class="line">);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md743"></a>
Helper Functions</h3>
<div class="fragment"><div class="line"><span class="comment">// Create void error result (for common::VoidResult)</span></div>
<div class="line">common::VoidResult make_logger_void_result(logger_error_code code,</div>
<div class="line">                                           <span class="keyword">const</span> std::string&amp; message = <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create typed error result</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">result&lt;T&gt; make_logger_error(logger_error_code code,</div>
<div class="line">                            <span class="keyword">const</span> std::string&amp; message = <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Convert error code to string</span></div>
<div class="line">std::string logger_error_to_string(logger_error_code code);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md744"></a>
Writers</h2>
<h3><a class="anchor" id="autotoc_md745"></a>
&lt;tt&gt;kcenon::logger::console_writer&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>console_writer : <span class="keyword">public</span> base_writer {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    console_writer(<span class="keywordtype">bool</span> use_color = <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordtype">void</span> set_use_color(<span class="keywordtype">bool</span> use_color);</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md746"></a>
&lt;tt&gt;kcenon::logger::file_writer&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>file_writer : <span class="keyword">public</span> base_writer {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    file_writer(<span class="keyword">const</span> std::string&amp; filename);</div>
<div class="line">    common::VoidResult open();</div>
<div class="line">    common::VoidResult close();</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md747"></a>
&lt;tt&gt;kcenon::logger::rotating_file_writer&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>rotating_file_writer : <span class="keyword">public</span> base_writer {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">enum class</span> rotation_type {</div>
<div class="line">        size_based,</div>
<div class="line">        time_based,</div>
<div class="line">        daily,</div>
<div class="line">        hourly</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    rotating_file_writer(<span class="keyword">const</span> std::string&amp; filename,</div>
<div class="line">                         std::size_t max_size,</div>
<div class="line">                         std::size_t max_files);</div>
<div class="line"> </div>
<div class="line">    rotating_file_writer(<span class="keyword">const</span> std::string&amp; filename,</div>
<div class="line">                         rotation_type type,</div>
<div class="line">                         std::size_t max_files);</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md748"></a>
&lt;tt&gt;kcenon::logger::network_writer&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>network_writer : <span class="keyword">public</span> base_writer {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">enum class</span> protocol_type { tcp, udp };</div>
<div class="line"> </div>
<div class="line">    network_writer(<span class="keyword">const</span> std::string&amp; host,</div>
<div class="line">                   uint16_t port,</div>
<div class="line">                   protocol_type protocol = protocol_type::tcp);</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md749"></a>
&lt;tt&gt;kcenon::logger::critical_writer&lt;/tt&gt;</h3>
<p>Synchronous writer for critical messages that bypass async queue:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>critical_writer : <span class="keyword">public</span> base_writer {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    critical_writer(std::unique_ptr&lt;base_writer&gt; underlying_writer);</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md750"></a>
&lt;tt&gt;kcenon::logger::batch_writer&lt;/tt&gt;</h3>
<p>Wraps another writer with batching support:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>batch_writer : <span class="keyword">public</span> base_writer {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">struct </span>config {</div>
<div class="line">        std::size_t max_batch_size = 100;</div>
<div class="line">        std::chrono::milliseconds flush_interval{1000};</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    batch_writer(std::unique_ptr&lt;base_writer&gt; underlying_writer,</div>
<div class="line">                 <span class="keyword">const</span> config&amp; cfg = {});</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md751"></a>
Filters</h2>
<h3><a class="anchor" id="autotoc_md752"></a>
&lt;tt&gt;kcenon::logger::filters::level_filter&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>level_filter : <span class="keyword">public</span> log_filter_interface {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    level_filter(logger_system::log_level min_level);</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md753"></a>
&lt;tt&gt;kcenon::logger::filters::regex_filter&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>regex_filter : <span class="keyword">public</span> log_filter_interface {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    regex_filter(<span class="keyword">const</span> std::string&amp; pattern, <span class="keywordtype">bool</span> include = <span class="keyword">true</span>);</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md754"></a>
&lt;tt&gt;kcenon::logger::filters::function_filter&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>function_filter : <span class="keyword">public</span> log_filter_interface {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using </span>filter_func = std::function&lt;bool(<span class="keyword">const</span> log_entry&amp;)&gt;;</div>
<div class="line">    function_filter(filter_func func);</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md755"></a>
&lt;tt&gt;kcenon::logger::filters::composite_filter&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>composite_filter : <span class="keyword">public</span> log_filter_interface {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">enum class</span> logic_type { AND, OR };</div>
<div class="line"> </div>
<div class="line">    composite_filter(logic_type logic = logic_type::AND);</div>
<div class="line">    <span class="keywordtype">void</span> add_filter(std::unique_ptr&lt;log_filter_interface&gt; filter);</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md756"></a>
Formatters</h2>
<h3><a class="anchor" id="autotoc_md757"></a>
&lt;tt&gt;kcenon::logger::plain_formatter&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>plain_formatter : <span class="keyword">public</span> base_formatter {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::string format(<span class="keyword">const</span> log_entry&amp; entry) <span class="keyword">const override</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md758"></a>
&lt;tt&gt;kcenon::logger::json_formatter&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>json_formatter : <span class="keyword">public</span> base_formatter {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    json_formatter(<span class="keywordtype">bool</span> pretty_print = <span class="keyword">false</span>);</div>
<div class="line">    std::string format(<span class="keyword">const</span> log_entry&amp; entry) <span class="keyword">const override</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md759"></a>
Backend Integration</h2>
<h3><a class="anchor" id="autotoc_md760"></a>
Integration Backend Interface</h3>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>backends {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>integration_backend {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~integration_backend() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Convert between log level types</span></div>
<div class="line">    <span class="keyword">virtual</span> common::interfaces::log_level to_common_level(</div>
<div class="line">        logger_system::log_level level) <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> logger_system::log_level from_common_level(</div>
<div class="line">        common::interfaces::log_level level) <span class="keyword">const</span> = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace backends</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md761"></a>
Standalone Backend (Default)</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>standalone_backend : <span class="keyword">public</span> integration_backend {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    standalone_backend() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="comment">// Uses std::jthread for async processing</span></div>
<div class="line">    <span class="comment">// No external dependencies</span></div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md762"></a>
Monitoring Integration</h2>
<h3><a class="anchor" id="autotoc_md763"></a>
IMonitor Integration (Phase 2.2.4)</h3>
<div class="fragment"><div class="line">logger_builder&amp; with_monitoring(</div>
<div class="line">    std::shared_ptr&lt;common::interfaces::IMonitor&gt; monitor);</div>
<div class="line">logger_builder&amp; with_health_check_interval(std::chrono::milliseconds interval);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md764"></a>
Usage Examples</h2>
<h3><a class="anchor" id="autotoc_md765"></a>
Basic Usage with ILogger Interface</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/logger/core/logger.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;kcenon/logger/core/logger_builder.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;kcenon/logger/writers/console_writer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>kcenon::logger;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">auto</span> result = logger_builder()</div>
<div class="line">        .use_template(<span class="stringliteral">&quot;production&quot;</span>)</div>
<div class="line">        .add_writer(<span class="stringliteral">&quot;console&quot;</span>, std::make_unique&lt;console_writer&gt;())</div>
<div class="line">        .build();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!result) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed: &quot;</span> &lt;&lt; result.error().message() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> logger = std::move(result.value());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Using ILogger interface (recommended)</span></div>
<div class="line">    logger-&gt;log(common::interfaces::log_level::info, <span class="stringliteral">&quot;Application started&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Using C++20 source_location (automatic)</span></div>
<div class="line">    logger-&gt;log(common::interfaces::log_level::debug, <span class="stringliteral">&quot;Debug message&quot;</span>);</div>
<div class="line">    <span class="comment">// Source location captured automatically!</span></div>
<div class="line"> </div>
<div class="line">    logger-&gt;flush();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md766"></a>
Native API (Backward Compatible)</h3>
<div class="fragment"><div class="line"><span class="comment">// Using native logger_system types</span></div>
<div class="line">logger-&gt;log(log_level::info, <span class="stringliteral">&quot;Message with native types&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Note: The source location is auto-captured internally in v2.x+</span></div>
<div class="line"><span class="comment">// The legacy API with __FILE__, __LINE__, __func__ is deprecated and will be removed in v3.0.0</span></div>
<div class="line">logger-&gt;log(log_level::error, <span class="stringliteral">&quot;Error occurred&quot;</span>);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md767"></a>
Configuration Strategies</h3>
<div class="fragment"><div class="line"><span class="keyword">auto</span> logger = logger_builder()</div>
<div class="line">    .for_environment(deployment_env::production)</div>
<div class="line">    .with_performance_tuning(performance_level::high_throughput)</div>
<div class="line">    .auto_configure()  <span class="comment">// Override with environment variables</span></div>
<div class="line">    .add_writer(<span class="stringliteral">&quot;file&quot;</span>, std::make_unique&lt;rotating_file_writer&gt;(</div>
<div class="line">        <span class="stringliteral">&quot;logs/app.log&quot;</span>, 10 * 1024 * 1024, 5))</div>
<div class="line">    .build()</div>
<div class="line">    .value();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md768"></a>
Custom Writer</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>custom_writer : <span class="keyword">public</span> kcenon::logger::log_writer_interface {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    common::VoidResult write(<span class="keyword">const</span> kcenon::logger::log_entry&amp; entry)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Custom implementation</span></div>
<div class="line">        <span class="keywordflow">return</span> common::ok();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    common::VoidResult flush()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> common::ok();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md769"></a>
Filtering</h3>
<div class="fragment"><div class="line"><span class="keyword">auto</span> logger = logger_builder()</div>
<div class="line">    .add_level_filter(log_level::warning)</div>
<div class="line">    .add_regex_filter(<span class="stringliteral">&quot;critical|important&quot;</span>, <span class="keyword">true</span>)</div>
<div class="line">    .add_function_filter([](<span class="keyword">const</span> log_entry&amp; entry) {</div>
<div class="line">        <span class="keywordflow">return</span> entry.file.find(<span class="stringliteral">&quot;debug&quot;</span>) == std::string::npos;</div>
<div class="line">    })</div>
<div class="line">    .build();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md770"></a>
Thread Safety</h2>
<p>All public methods of the logger class are thread-safe. Writers are called sequentially (no concurrent writes to the same writer).</p>
<h2><a class="anchor" id="autotoc_md771"></a>
Performance Considerations</h2>
<ul>
<li>Use asynchronous mode for better performance</li>
<li>Batch size affects latency vs throughput trade-off</li>
<li>Larger buffer sizes reduce contention but increase memory usage</li>
<li>Use <code>is_enabled()</code> check before expensive message construction</li>
<li>Consider <code>critical_writer</code> only for truly critical messages</li>
</ul>
<h2><a class="anchor" id="autotoc_md772"></a>
Migration from v2.x</h2>
<p>See <a class="el" href="md__2home_2runner_2work_2logger__system_2logger__system_2docs_2guides_2MIGRATION__GUIDE.html">MIGRATION_GUIDE.md</a> for detailed migration instructions.</p>
<p>Key changes in v3.0:</p><ul>
<li>Namespace: <code>logger_module</code> → <code>kcenon::logger</code></li>
<li>Interface: Implements <code>common::interfaces::ILogger</code></li>
<li>thread_system: Now optional (standalone mode is default)</li>
<li>C++20 source_location support</li>
</ul>
<hr  />
<p><em>Last Updated: 2025-12-10</em> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jan 19 2026 11:38:06 for Logger System by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
